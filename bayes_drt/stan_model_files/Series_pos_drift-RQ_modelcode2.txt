data {
	int<lower=0> N; // number of measured frequencies
	int<lower=0> K; // number of basis functions
	// int<lower=0> S; // number of spectra
	matrix[N, K] A; // stacked A matrix ([[A'] [A'']])
	vector[N] Z; // stacked impedance vector ([Z' Z'']^T)
	vector[N/2] freq; // measured frequencies
	vector[N/2] time; // measurement times
	int<lower=0> N_tilde; // number of frequencies to predict
	matrix[N_tilde,K] A_tilde; //stacked A matrix for prediction
	vector[N_tilde/2] freq_tilde; // frequencies to predict
	matrix[K,K] L0; // 0th order differentiation matrix
	matrix[K,K] L1; // 1st order differentiation matrix
	matrix[K,K] L2; // 2nd order differentiation matrix
	real<lower=0> sigma_min; // noise level floor
	real<lower=0> ups_alpha; // shape for inverse gamma distribution on ups
	real<lower=0> ups_beta; // rate for inverse gamma distribution on ups
	real<lower=0> induc_scale;
	
	// drift inputs
	real min_tau_rq;
	real max_tau_rq;
	real min_k;
	real max_k;
	real<lower=0> sigma_R_rq_scale;
	//real min_tau_Rinf;
	//real max_tau_Rinf;
}
transformed data {
	vector [N/2] omega = 2*pi()*freq;
	vector [N] induc_vec = append_row(rep_vector(0,N/2), omega);
	real min_log_tau_rq = log(min_tau_rq);
	real max_log_tau_rq = log(max_tau_rq);
	real min_ln_k = log(min_k);
	real max_ln_k = log(max_k);
}
parameters {
	real<lower=0> Rinf0_raw;
	real<lower=0> induc_raw;
	vector<lower=0>[K] x1;
	real<lower=0> sigma_res_raw;
	real<lower=0> alpha_prop_raw;
	real<lower=0> alpha_re_raw;
	real<lower=0> alpha_im_raw;
	vector<lower=0>[K] ups_x1_raw;
	real<lower=0> d0_strength_x1;
	real<lower=0> d1_strength_x1;
	real<lower=0> d2_strength_x1;
	
	real<lower=min_ln_k,upper=max_ln_k> ln_k; // drift rate constant
	real R_rq; // change in polarization resistance
	real<lower=0> R_rq_scale_raw;
	real<lower=0,upper=1> phi_rq; // phi parameter for time-dependent ZARC (RQ) element
	real<lower=min_log_tau_rq,upper=max_log_tau_rq> log_tau_rq; // log time constant for time-dependent ZARC
	real<lower=-100*Rinf0_raw> delta_Rinf; // change in R_inf. Cannot result in negative R_inf
	//real<lower=min_log_tau_Rinf,upper=max_log_tau_Rinf> log_tau_Rinf; // log time constant for changes in Rinf
}
transformed parameters {
	
	// inductance (not time-dependent)
	real<lower=0> induc = induc_raw*induc_scale;
	
	// time-dependent ZARC (RQ) contribution
	real<lower=0> R_rq_scale = R_rq_scale_raw*sigma_R_rq_scale;
	real R_rq_raw = R_rq / R_rq_scale;
	vector[N/2] Z_rq_deno;
	vector[N/2] Z_rq_re;
	vector[N/2] Z_rq_im;
	vector[N/2] Ft = exp(-exp(ln_k)*time); // ZARC magnitude as function of time
	
	vector[N] ZFt_rq; // Z_rq times Ft
	
	// predicted impedance, Z_hat
	vector[N] Z_hat;
	vector[N] Z_hat_re; 
	vector[N] Z_hat_im; 
	
	// calculate time-dependent Rinf vector
	vector[N] Rinf = append_row(
								100*Rinf0_raw + delta_Rinf*Ft, // real part
								rep_vector(0,N/2) // imag part
								);
	
	// complexity functions
	vector<lower=0>[K] q_x1 = sqrt(d0_strength_x1*square(L0*x1) + d1_strength_x1*square(L1*x1) + d2_strength_x1*square(L2*x1));
	
	// error contributions
	real<lower=0> sigma_res = sigma_res_raw*0.05;
	real<lower=0> alpha_prop = alpha_prop_raw*0.05;
	real<lower=0> alpha_re = alpha_re_raw*0.05;
	real<lower=0> alpha_im = alpha_im_raw*0.05;
	vector<lower=0>[N] sigma_tot; 
									
	// upsilon and delta_upsilon
	vector<lower=0>[K] ups_x1 = ups_x1_raw * 0.15;
	vector[K-2] dups_x1;

	// time constants
	real<lower=0> tau_rq = exp(log_tau_rq);
	//real<lower=0> tau_Rinf = exp(log_tau_Rinf);

	// calculate time-depndent Z_rq contribution
	for (n in 1:N/2){
		Z_rq_deno[n] = square(1+ pow(omega[n]*tau_rq,phi_rq)*cos(phi_rq*pi()/2)) + square(pow(omega[n]*tau_rq,phi_rq)*sin(phi_rq*pi()/2));
		Z_rq_re[n] = (1 + pow(omega[n]*tau_rq,phi_rq)*cos(phi_rq*pi()/2))/Z_rq_deno[n];
		Z_rq_im[n] = -(pow(omega[n]*tau_rq,phi_rq)*sin(phi_rq*pi()/2))/Z_rq_deno[n];
		}
	ZFt_rq = append_row(Z_rq_re .* Ft, Z_rq_im .* Ft);
	ZFt_rq *= R_rq;	
	
	// calculate Z_hat
	Z_hat = A*x1; // final (stable) DRT contribution
	Z_hat += Rinf + induc*induc_vec; // time-dependent Rinf and constant inductance contributions
	Z_hat += ZFt_rq; // time-dependent ZARC contribution
	
		
	// separate real and imag parts for use in sigma_tot
	Z_hat_re = append_row(Z_hat[1:N/2],Z_hat[1:N/2]);
	Z_hat_im = append_row(Z_hat[N/2+1:N],Z_hat[N/2+1:N]);
	
	// calculate total error scale
	sigma_tot = sqrt(
						square(sigma_min) + square(sigma_res) + square(alpha_prop*Z_hat)
						+ square(alpha_re*Z_hat_re) + square(alpha_im*Z_hat_im)
					);
									
	// calculate delta_upsilon
	for (k in 1:K-2){
		dups_x1[k] = 0.5*(ups_x1[k+1] - 0.5*(ups_x1[k] + ups_x1[k+2]))/ups_x1[k+1];
		}
}
model {
	d0_strength_x1 ~ inv_gamma(5,5);
	d1_strength_x1 ~ inv_gamma(5,5);
	d2_strength_x1 ~ inv_gamma(5,5);
	ups_x1_raw ~ inv_gamma(ups_alpha,ups_beta);
	Rinf0_raw ~ std_normal();
	delta_Rinf ~ std_normal();
	induc_raw ~ std_normal();
	q_x1 ~ normal(0,ups_x1);
	dups_x1 ~ std_normal();
	Z ~ normal(Z_hat,sigma_tot);
	sigma_res_raw ~ std_normal();
	alpha_prop_raw ~ std_normal();
	alpha_re_raw ~ std_normal();
	alpha_im_raw ~ std_normal();
	
	// drift parameters
	log_tau_rq ~ uniform(min_log_tau_rq,max_log_tau_rq);
	R_rq_scale_raw ~ std_normal();
	R_rq_raw ~ std_normal();
}
// generated quantities {
// 	vector[N_tilde] Z_hat_tilde
// 		= A_tilde*x + Rinf*Rinf_vec_tilde + induc*induc_vec_tilde;
// }