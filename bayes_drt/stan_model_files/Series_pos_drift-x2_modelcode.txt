data {
	int<lower=0> N; // number of measured frequencies
	int<lower=0> K; // number of basis functions
	// int<lower=0> S; // number of spectra
	matrix[N, K] A; // stacked A matrix ([[A'] [A'']])
	vector[N] Z; // stacked impedance vector ([Z' Z'']^T)
	vector[N/2] freq; // measured frequencies
	vector[N/2] time; // measurement times
	int<lower=0> N_tilde; // number of frequencies to predict
	matrix[N_tilde,K] A_tilde; //stacked A matrix for prediction
	vector[N_tilde/2] freq_tilde; // frequencies to predict
	matrix[K,K] L0; // 0th order differentiation matrix
	matrix[K,K] L1; // 1st order differentiation matrix
	matrix[K,K] L2; // 2nd order differentiation matrix
	real<lower=0> sigma_min; // noise level floor
	real<lower=0> ups_alpha; // shape for inverse gamma distribution on ups
	real<lower=0> ups_beta; // rate for inverse gamma distribution on ups
	real<lower=0> induc_scale;
	real min_tau_x1;
	real max_tau_x1;
	real min_tau_x2;
	real max_tau_x2;
}
transformed data {
	// vector [N] Rinf_vec = append_row(rep_vector(1,N/2), rep_vector(0,N/2));
	vector [N] induc_vec = append_row(rep_vector(0,N/2), 2*pi()*freq);
	vector [N_tilde] Rinf_vec_tilde = append_row(rep_vector(1,N_tilde/2), rep_vector(0,N_tilde/2));
	vector [N_tilde] induc_vec_tilde = append_row(rep_vector(0,N_tilde/2), 2*pi()*freq_tilde);
	matrix[K,N] T = rep_matrix(append_col(time',time'), K);
	real min_log_tau_x1 = log(min_tau_x1);
	real max_log_tau_x1 = log(max_tau_x1);
	real min_log_tau_x2 = log(min_tau_x2);
	real max_log_tau_x2 = log(max_tau_x2);
}
parameters {
	real<lower=0> Rinf0_raw;
	real dRinf_raw;
	real<lower=0> induc_raw;
	vector<lower=0>[K] x0;
	vector<lower=0>[K] x1;
	vector[K] x2;
	real<lower=0> sigma_res_raw;
	real<lower=0> alpha_prop_raw;
	real<lower=0> alpha_re_raw;
	real<lower=0> alpha_im_raw;
	vector<lower=0>[K] ups_x0_raw;
	vector<lower=0>[K] ups_x1_raw;
	vector<lower=0>[K] ups_x2_raw;
	real<lower=0> d0_strength_x0;
	real<lower=0> d1_strength_x0;
	real<lower=0> d2_strength_x0;
	real<lower=0> d0_strength_x1;
	real<lower=0> d1_strength_x1;
	real<lower=0> d2_strength_x1;
	real<lower=0> d0_strength_x2;
	real<lower=0> d1_strength_x2;
	real<lower=0> d2_strength_x2;
	real<lower=min_log_tau_x1,upper=max_log_tau_x1> log_tau_x1; // log time constant for changes in x
	real<lower=min_log_tau_x2,upper=max_log_tau_x2> log_tau_x2; // log time constant for changes in x
	real<lower=-2,upper=12> log_tau_Rinf; // log time constant for changes in Rinf
}
transformed parameters {
	// construct time-dependent coefficient matrix, X
	matrix[K,N] X0 = rep_matrix(x0,N); 
	matrix[K,N] X1 = rep_matrix(x1,N);
	matrix[K,N] X2 = rep_matrix(x2,N);
	matrix[K,N] X = X0 + (X1-X0) .* (1 - exp(-T/exp(log_tau_x1))) + X2 .* (1 - exp(-T/exp(log_tau_x2)));
	// calculate elementwise product of A and X'
	matrix[N,K] AX = A .* X';
	
	// calculate time-dependent Rinf vector
	vector[N] Rinf = append_row(
								100*(Rinf0_raw + dRinf_raw*(1 - exp(-time/exp(log_tau_Rinf)))), // real part
								rep_vector(0,N/2) // imag part
								);
	// inductance (not time-dependent)
	real<lower=0> induc = induc_raw*induc_scale;
	
	// predicted impedance, Z_hat
	vector[N] Z_hat;
	vector[N] Z_hat_re; 
	vector[N] Z_hat_im; 
	
	// complexity functions
	vector<lower=0>[K] q_x0 = sqrt(d0_strength_x0*square(L0*x0) + d1_strength_x0*square(L1*x0) + d2_strength_x0*square(L2*x0));
	vector<lower=0>[K] q_x1 = sqrt(d0_strength_x1*square(L0*x1) + d1_strength_x1*square(L1*x1) + d2_strength_x1*square(L2*x1));
	vector<lower=0>[K] q_x2 = sqrt(d0_strength_x2*square(L0*x2) + d1_strength_x2*square(L1*x2) + d2_strength_x2*square(L2*x2));
	
	// error contributions
	real<lower=0> sigma_res = sigma_res_raw*0.05;
	real<lower=0> alpha_prop = alpha_prop_raw*0.05;
	real<lower=0> alpha_re = alpha_re_raw*0.05;
	real<lower=0> alpha_im = alpha_im_raw*0.05;
	vector<lower=0>[N] sigma_tot; 
									
	// upsilon and delta_upsilon
	vector<lower=0>[K] ups_x0 = ups_x0_raw * 0.15;
	vector<lower=0>[K] ups_x1 = ups_x1_raw * 0.15;
	vector<lower=0>[K] ups_x2 = ups_x2_raw * 0.15;
	vector[K-2] dups_x0;
	vector[K-2] dups_x1;							
	vector[K-2] dups_x2;
	
	// calculate Z_hat
	for (n in 1:N)
		Z_hat[n] = sum(row(AX,n));
	Z_hat += Rinf + induc*induc_vec;
	// separate real and imag parts for use in sigma_tot
	Z_hat_re = append_row(Z_hat[1:N/2],Z_hat[1:N/2]);
	Z_hat_im = append_row(Z_hat[N/2+1:N],Z_hat[N/2+1:N]);
	
	// calculate total error scale
	sigma_tot = sqrt(
						square(sigma_min) + square(sigma_res) + square(alpha_prop*Z_hat)
						+ square(alpha_re*Z_hat_re) + square(alpha_im*Z_hat_im)
					);
									
	// calculate delta_upsilon
	for (k in 1:K-2){
		dups_x0[k] = 0.5*(ups_x0[k+1] - 0.5*(ups_x0[k] + ups_x0[k+2]))/ups_x0[k+1];
		dups_x1[k] = 0.5*(ups_x1[k+1] - 0.5*(ups_x1[k] + ups_x1[k+2]))/ups_x1[k+1];
		dups_x2[k] = 0.5*(ups_x2[k+1] - 0.5*(ups_x2[k] + ups_x2[k+2]))/ups_x2[k+1];
		}
}
model {
	d0_strength_x0 ~ inv_gamma(5,5);
	d1_strength_x0 ~ inv_gamma(5,5);
	d2_strength_x0 ~ inv_gamma(5,5);
	d0_strength_x1 ~ inv_gamma(5,5);
	d1_strength_x1 ~ inv_gamma(5,5);
	d2_strength_x1 ~ inv_gamma(5,5);
	d0_strength_x2 ~ inv_gamma(5,5);
	d1_strength_x2 ~ inv_gamma(5,5);
	d2_strength_x2 ~ inv_gamma(5,5);
	ups_x0_raw ~ inv_gamma(ups_alpha,ups_beta);
	ups_x1_raw ~ inv_gamma(ups_alpha,ups_beta);
	ups_x2_raw ~ inv_gamma(ups_alpha,ups_beta);
	Rinf0_raw ~ std_normal();
	dRinf_raw ~ std_normal();
	induc_raw ~ std_normal();
	q_x0 ~ normal(0,ups_x0);
	q_x1 ~ normal(0,ups_x1);
	q_x2 ~ normal(0,ups_x2);
	dups_x0 ~ std_normal();
	dups_x1 ~ std_normal();
	dups_x2 ~ std_normal();
	Z ~ normal(Z_hat,sigma_tot);
	sigma_res_raw ~ std_normal();
	alpha_prop_raw ~ std_normal();
	alpha_re_raw ~ std_normal();
	alpha_im_raw ~ std_normal();
	log_tau_x1 ~ uniform(min_log_tau_x1,max_log_tau_x1);
	log_tau_x2 ~ uniform(min_log_tau_x2,max_log_tau_x2);
	log_tau_Rinf ~ uniform(-2,12);
}
// generated quantities {
// 	vector[N_tilde] Z_hat_tilde
// 		= A_tilde*x + Rinf*Rinf_vec_tilde + induc*induc_vec_tilde;
// }