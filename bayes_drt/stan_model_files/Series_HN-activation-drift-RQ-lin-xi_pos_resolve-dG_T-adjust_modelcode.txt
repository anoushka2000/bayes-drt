functions {
	// for impedance calculation
	real HN_x(real omega, real tau0, real beta) {
		// Intermediate "x" variable
		return 1+ pow(omega*tau0,beta)*cos(beta*pi()/2);
	}
	real HN_y(real omega, real tau0, real beta){
		// Intermediate "y" variable
		return pow(omega*tau0,beta)*sin(beta*pi()/2);
	}
	real Zmod_HN(real alpha, real x, real y) {
		return pow(sqrt(square(x) + square(y)),-alpha);
	}
	real theta_HN(real alpha, real x, real y) {
		return -alpha*atan2(y,x);
	}
	
	// Arrhenius functions
	real k_B() {
		// Boltzmann constant (eV/K)
		return 8.617333e-5; 
	} 
	real arrhenius(real temp, real T_base, real dG, real y_base) {
		return y_base*exp((dG/k_B())*(1/temp - 1/T_base));
	}
}
data {
	// dimensions
	int<lower=0> N; // number of measured frequencies
	int<lower=0> K; // number of HN basis functions
	int<lower=0> P; // number of distinct temperatures
	
	// impedance data
	vector[N] freq; // measured frequencies
	vector[N] times;
	vector[2*N] Z; // stacked impedance vector ([Z' Z'']^T)
	vector<lower=0>[N] rel_Z_scale;
	
	// temperature
	vector[N] temp; // measurement temperatures (K)
	real<lower=0> T_base; // base temperature (K)
	int temp_start_indices[P]; // indices of new temperature starts
	real<lower=0> temp_uncertainty; // maximum temperature offset
	real<lower=0> temp_offset_scale; // scale for normal prior on temp_offset
	
	// fixed hyperparameters
	real<lower=0> R_i_base_scale_alpha;
	real<lower=0> R_i_base_scale_beta;
	real min_tau_HN;
	real max_tau_HN;
	real<lower=0> sigma_min; // noise level floor
	real<lower=0> sigma_res_scale;
	real<lower=0> alpha_prop_scale;
	real<lower=0> alpha_re_scale;
	real<lower=0> alpha_im_scale;
	real<lower=0> induc_scale; // inductance scale
	
	// activation inputs
	real<lower=0> max_delta_G;
	real<lower=0> ln_phi_T_scale;
	real<lower=0> max_phi_T;
	int<lower=1> idx_delta_G_1;
	int<lower=1> idx_delta_G_2;
	real mu_diff_delta_G_21;
	real sigma_diff_delta_G_21;
	
	// drift inputs;
	real min_tau_rq;
	real max_tau_rq;
	vector<lower=0>[P] sigma_R_rq_scale;
}
transformed data {
	vector [N] omega = freq*2*pi();
	real min_lntau_HN = log(min_tau_HN);
	real max_lntau_HN = log(max_tau_HN);
	vector[2*N] rel_Z_scale_stack = append_row(rel_Z_scale,rel_Z_scale);
	real max_ln_phi_T = log(max_phi_T);
	real min_log_tau_rq = log(min_tau_rq);
	real max_log_tau_rq = log(max_tau_rq);
	vector[P] rel_Z_scale_condensed;
	vector[N] Ft; // ZARC magnitude as function of time. Linear approximation
	// get temp indices
	int temp_end_indices[P];
	for (p in 1:P-1) {
		temp_end_indices[p] = temp_start_indices[p+1] - 1;
	}
	temp_end_indices[P] = N;
	// get condensed rel_Z_scale
	for (p in 1:P) {
		rel_Z_scale_condensed[p] = rel_Z_scale[temp_start_indices[p]];
	}
	// calculate Ft
	for (p in 1:P) {
		int start_idx = temp_start_indices[p];
		int end_idx = temp_end_indices[p];
		Ft[start_idx:end_idx] = (times[start_idx:end_idx] - times[start_idx]) ./ (times[end_idx] - times[start_idx]);
	}
}
parameters {
	// impedance offsets
	real<lower=0> Rinf_base_raw;
	real<lower=0> induc_raw;
	
	// HN parameters
	vector<lower=0>[K] R_i_base;
	vector<lower=0>[K] R_i_base_scale;
	vector<lower=min_lntau_HN,upper=max_lntau_HN>[K] lntau_i_base;
	vector<lower=0,upper=1>[K] alpha_HN;
	vector<lower=0,upper=1>[K] beta_HN;
	
	// activation parameters
	vector<lower=0,upper=max_delta_G>[K] delta_G; // activation energy for R_HN
	vector<upper=max_ln_phi_T/ln_phi_T_scale>[K] ln_phi_T_raw; // ln of activation energy factor for tau
	real<lower=0,upper=max_delta_G> delta_G_Rinf; // activation energy for Rinf
	vector<lower=-temp_uncertainty/temp_offset_scale,upper=temp_uncertainty/temp_offset_scale>[P] temp_offset_raw; // no entry for 1st temp - keep fixed
	
	// drift parameters
	vector[P] R_rq_raw; // change in polarization resistance
	vector<lower=0>[P] R_rq_scale_raw;
	vector<lower=0,upper=1>[P] phi_rq; // phi parameter for time-dependent ZARC (RQ) element
	vector<lower=min_log_tau_rq,upper=max_log_tau_rq>[P] log_tau_rq; // log time constant for time-dependent ZARC
	
	// error structure parameters
	real<lower=0> sigma_res_raw;
	real<lower=0> alpha_prop_raw;
	real<lower=0> alpha_re_raw;
	real<lower=0> alpha_im_raw;
	
}
transformed parameters {
	// impedance offsets
	real<lower=0> Rinf_base = Rinf_base_raw*100; // R_inf_base has effective scale of 100
	real<lower=0> induc = induc_raw*induc_scale; // induc has effective scale of induc_scale
	
	// drift parameters
	vector<lower=0>[P] R_rq_scale = R_rq_scale_raw .* sigma_R_rq_scale;
	vector[P] R_rq = R_rq_raw .* rel_Z_scale_condensed;
	//vector[P] R_rq_raw = R_rq ./ R_rq_scale;
	vector[N] Z_rq_deno;
	vector[N] Z_rq_re;
	vector[N] Z_rq_im;
	
	// activation parameters
	real diff_delta_G_21 = delta_G[idx_delta_G_2] - delta_G[idx_delta_G_1];
	vector[K] ln_phi_T = ln_phi_T_raw*ln_phi_T_scale; // ln_phi_T has effective scale of 0.2
	vector<lower=-temp_uncertainty,upper=temp_uncertainty>[P] temp_offset = temp_offset_raw*temp_offset_scale;
	vector[N] temp_actual;
	
	// error structure parameters
	real<lower=0> sigma_res = sigma_res_raw*0.05;
	real<lower=0> alpha_prop = alpha_prop_raw*0.05;
	real<lower=0> alpha_re = alpha_re_raw*0.05;
	real<lower=0> alpha_im = alpha_im_raw*0.05;
	vector[2*N] sigma_tot; 
	
	// parameters for Z_hat calculation
	vector[2*N] Z_hat;
	vector[N] Z_hat_re = rep_vector(0,N);
	vector[N] Z_hat_im = rep_vector(0,N);
	
	// calculate actual temp
	for (p in 1:P) {
		temp_actual[temp_start_indices[p]:temp_end_indices[p]] = temp[temp_start_indices[p]:temp_end_indices[p]] + temp_offset[p];
	}
	
	// calculate static Z_hat
	for (k in 1:K) {
		real phi_T = exp(ln_phi_T[k]);
		real tau_i_base = exp(lntau_i_base[k]);
		for (n in 1:N){
			// calculate R and tau at temp
			real R_i = arrhenius(temp_actual[n],T_base,delta_G[k],R_i_base[k]);
			real tau_i = arrhenius(temp_actual[n],T_base,phi_T*delta_G[k],tau_i_base);
			
			// temperature-dependent R and tau feed into impedance calcs
			real x = HN_x(omega[n],tau_i,beta_HN[k]);
			real y = HN_y(omega[n],tau_i,beta_HN[k]);
			real Zmod = Zmod_HN(alpha_HN[k],x,y);
			real theta = theta_HN(alpha_HN[k],x,y);
			
			Z_hat_re[n] += R_i*Zmod*cos(theta);
			Z_hat_im[n] += R_i*Zmod*sin(theta);
		}
	}
	
	// add offsets
	Z_hat_re += Rinf_base*exp((delta_G_Rinf/k_B())*(1 ./temp_actual - 1/T_base)); //not using arrhenius here to avoid looping
	Z_hat_im += induc*omega;
	
	// calculate time-dependent Z_rq contribution
	for (p in 1:P) {
		int start_idx = temp_start_indices[p];
		int end_idx = temp_end_indices[p];
		real tau_rq_p = exp(log_tau_rq[p]);
		real phi_rq_p = phi_rq[p];
		
		for (n in start_idx:end_idx){
			Z_rq_deno[n] = square(1+ pow(omega[n]*tau_rq_p,phi_rq_p)*cos(phi_rq_p*pi()/2)) + square(pow(omega[n]*tau_rq_p,phi_rq_p)*sin(phi_rq_p*pi()/2));
			Z_rq_re[n] = (1 + pow(omega[n]*tau_rq_p,phi_rq_p)*cos(phi_rq_p*pi()/2))/Z_rq_deno[n];
			Z_rq_im[n] = -(pow(omega[n]*tau_rq_p,phi_rq_p)*sin(phi_rq_p*pi()/2))/Z_rq_deno[n];
			}
		Z_rq_re[start_idx:end_idx] *= R_rq[p];
		Z_rq_im[start_idx:end_idx] *= R_rq[p];
	}
	
	// add Z_rq to Z_hat
	Z_hat_re += Z_rq_re .* Ft;
	Z_hat_im += Z_rq_im .* Ft;
	
	// concatenate real and imag parts
	Z_hat = append_row(Z_hat_re,Z_hat_im);
	
	// calculate error scale
	sigma_tot = sqrt(square(sigma_min*rel_Z_scale_stack) + square(sigma_res*rel_Z_scale_stack) + square(alpha_prop*Z_hat)
									+ square(alpha_re*append_row(Z_hat_re,Z_hat_re)) 
									+ square(alpha_im*append_row(Z_hat_im,Z_hat_im))
									);
}
model {
	// impedance offsets
	Rinf_base_raw ~ std_normal();
	induc_raw ~ std_normal();
	
	// HN parameters
	R_i_base_scale ~ inv_gamma(R_i_base_scale_alpha,R_i_base_scale_beta);
	R_i_base ~ normal(0,R_i_base_scale);
	
	// activation parameters
	diff_delta_G_21 ~ normal(mu_diff_delta_G_21,sigma_diff_delta_G_21);
	ln_phi_T_raw ~ std_normal();
	temp_offset_raw ~ std_normal();
	
	// drift parameters
	R_rq_scale_raw ~ std_normal();
	//R_rq_raw ~ std_normal();
	R_rq_raw ./ R_rq_scale  ~ std_normal();
	
	Z ~ normal(Z_hat,sigma_tot);
	sigma_res_raw ~ std_normal();
	alpha_prop_raw ~ std_normal();
	alpha_re_raw ~ std_normal();
	alpha_im_raw ~ std_normal();
}