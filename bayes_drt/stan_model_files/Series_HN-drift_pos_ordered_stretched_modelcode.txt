functions {
	// for impedance calculation
	real HN_x(real omega, real tau0, real beta) {
		// Intermediate "x" variable
		return 1+ pow(omega*tau0,beta)*cos(beta*pi()/2);
	}
	real HN_y(real omega, real tau0, real beta){
		// Intermediate "y" variable
		return pow(omega*tau0,beta)*sin(beta*pi()/2);
	}
	real Zmod_HN(real alpha, real x, real y) {
		return pow(sqrt(square(x) + square(y)),-alpha);
	}
	real theta_HN(real alpha, real x, real y) {
		return -alpha*atan2(y,x);
	}
	
	// for drift calculations
	real R_drift(real R_i, real R_f, real k_d, real beta, real time) {
		return R_i + (R_f - R_i)*(1 - exp(-pow(k_d*time,beta)));
	}
	real tau_drift(real tau_i, real R_i, real R_f, real k_d, real phi_d, real beta, real time) {
		return tau_i + tau_i*(pow(R_f/R_i,phi_d) - 1)*(1 - exp(-pow(k_d*time,beta))); 
	}
}
data {
	// dimensions
	int<lower=0> N; // number of measured frequencies
	int<lower=0> K; // number of HN basis functions
	
	// impedance data
	vector[N] freq; // measured frequencies
	vector[N] times;
	vector[2*N] Z; // stacked impedance vector ([Z' Z'']^T)
	vector<lower=0>[N] rel_Z_scale;

	// fixed hyperparameters
	real<lower=0> R_i_scale_alpha;
	real<lower=0> R_i_scale_beta;
	real<lower=0> sigma_min; // noise level floor
	real<lower=0> induc_scale; // inductance scale
	
	// drift inputs
	//real<lower=0> deltaR_scale_alpha;
	//real<lower=0> deltaR_scale_beta;
	vector<lower=0>[K] sigma_delta_R_scale;
	real<lower=0> sigma_delta_Rinf_scale;
	real<lower=0> max_phi_d;
	real<lower=0> ln_phi_d_scale;
	real<lower=0> min_k;
	real<lower=0> max_k;
	vector<lower=0>[K] ln_beta_t_scale;
	real<lower=0> ln_beta_t_Rinf_scale;
	
}
transformed data {
	vector [N] omega = freq*2*pi();
	vector[2*N] rel_Z_scale_stack = append_row(rel_Z_scale,rel_Z_scale);
	real max_ln_phi_d = log(max_phi_d);
	real min_lnk = log(min_k);
	real max_lnk = log(max_k);
}
parameters {
	// impedance offsets
	real<lower=0> Rinf_i_raw;
	real<lower=0> Rinf_f_raw;
	real<lower=0> delta_Rinf_scale_raw;
	real<lower=min_lnk,upper=max_lnk> ln_k_Rinf;
	real ln_beta_t_Rinf_raw;
	real<lower=0> induc_raw;
	
	// HN parameters
	vector<lower=0>[K] R_i;
	vector<lower=0>[K] R_i_scale;
	ordered[K] lntau_i;
	vector<lower=0,upper=1>[K] alpha_HN;
	vector<lower=0,upper=1>[K] beta_HN;
	
	// drift parameters
	vector<lower=0>[K] R_f;
	vector<lower=min_lnk,upper=max_lnk>[K] ln_k;
	vector<upper=max_ln_phi_d/ln_phi_d_scale>[K] ln_phi_d_raw; // ln of drift factor for tau
	vector<lower=0>[K] deltaR_scale_raw;
	vector[K] ln_beta_t_raw;
	
	// error structure parameters
	real<lower=0> sigma_res_raw;
	real<lower=0> alpha_prop_raw;
	real<lower=0> alpha_re_raw;
	real<lower=0> alpha_im_raw;
	
}
transformed parameters {
	// impedance offsets
	real<lower=0> Rinf_i = Rinf_i_raw*100; // R_inf has effective scale of 100
	real<lower=0> Rinf_f = Rinf_f_raw*100;
	real<lower=0> delta_Rinf_scale = delta_Rinf_scale_raw*sigma_delta_Rinf_scale;
	real delta_Rinf_raw = (Rinf_f - Rinf_i) / (Rinf_i*delta_Rinf_scale);
	real<lower=0> beta_t_Rinf = exp(ln_beta_t_Rinf_raw * ln_beta_t_Rinf_scale);
	real<lower=0> induc = induc_raw*induc_scale; // induc has effective scale of induc_scale
	
	// drift parameters
	vector<lower=0>[K] deltaR_scale = deltaR_scale_raw .* sigma_delta_R_scale;
	vector[K] deltaR_raw = (R_f - R_i) ./ (R_i .* deltaR_scale);
	vector[K] ln_phi_d = ln_phi_d_raw*ln_phi_d_scale;
	vector<lower=0>[K] beta_t = exp(ln_beta_t_raw .* ln_beta_t_scale);
	
	// error structure parameters
	real<lower=0> sigma_res = sigma_res_raw*0.05;
	real<lower=0> alpha_prop = alpha_prop_raw*0.05;
	real<lower=0> alpha_re = alpha_re_raw*0.05;
	real<lower=0> alpha_im = alpha_im_raw*0.05;
	vector[2*N] sigma_tot; 
	
	// parameters for Z_hat calculation
	vector[2*N] Z_hat;
	vector[N] Z_hat_re = rep_vector(0,N);
	vector[N] Z_hat_im = rep_vector(0,N);
	
	// calculate Z_hat
	for (k in 1:K) {
		real phi_d = exp(ln_phi_d[k]);
		real k_d = exp(ln_k[k]);
		real tau_i = exp(lntau_i[k]);
		for (n in 1:N){
			// calculate R(t) and tau(t) at time
			real R_t = R_drift(R_i[k], R_f[k], k_d, beta_t[k], times[n]);
			real tau_t = tau_drift(tau_i, R_i[k], R_f[k], k_d, phi_d, beta_t[k], times[n]);
			
			// time-dependent R_t and tau_t feed into impedance calcs
			real x = HN_x(omega[n],tau_t,beta_HN[k]);
			real y = HN_y(omega[n],tau_t,beta_HN[k]);
			real Zmod = Zmod_HN(alpha_HN[k],x,y);
			real theta = theta_HN(alpha_HN[k],x,y);
			
			Z_hat_re[n] += R_t*Zmod*cos(theta);
			Z_hat_im[n] += R_t*Zmod*sin(theta);
		}
	}
	
	for (n in 1:N) {
		Z_hat_re += R_drift(Rinf_i, Rinf_f, exp(ln_k_Rinf), beta_t_Rinf, times[n]);
	}
	
	Z_hat_im += induc*omega;
	Z_hat = append_row(Z_hat_re,Z_hat_im);
	
	// calculate error scale
	sigma_tot = sqrt(square(sigma_min*rel_Z_scale_stack) + square(sigma_res*rel_Z_scale_stack) + square(alpha_prop*Z_hat)
									+ square(alpha_re*append_row(Z_hat_re,Z_hat_re)) 
									+ square(alpha_im*append_row(Z_hat_im,Z_hat_im))
									);
}
model {
	// impedance offsets
	Rinf_i_raw ~ std_normal();
	delta_Rinf_scale_raw ~ std_normal();//inv_gamma(deltaR_scale_alpha,deltaR_scale_beta);
	delta_Rinf_raw ~ std_normal();
	ln_beta_t_Rinf_raw ~ std_normal();
	induc_raw ~ std_normal();
	
	// HN parameters
	R_i_scale ~ inv_gamma(R_i_scale_alpha,R_i_scale_beta);
	R_i ~ normal(0,R_i_scale);
	
	// drift parameters
	deltaR_scale_raw ~ std_normal(); //inv_gamma(deltaR_scale_alpha,deltaR_scale_beta);
	deltaR_raw ~ std_normal();
	ln_phi_d_raw ~ std_normal();
	ln_beta_t_raw ~ std_normal();
	
	Z ~ normal(Z_hat,sigma_tot);
	sigma_res_raw ~ std_normal();
	alpha_prop_raw ~ std_normal();
	alpha_re_raw ~ std_normal();
	alpha_im_raw ~ std_normal();
}