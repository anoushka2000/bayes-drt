functions {
	// for impedance calculation
	real HN_x(real omega, real tau0, real beta) {
		// Intermediate "x" variable
		return 1 + pow(omega*tau0,beta)*cos(beta*pi()/2);
	}
	real HN_y(real omega, real tau0, real beta){
		// Intermediate "y" variable
		return pow(omega*tau0,beta)*sin(beta*pi()/2);
	}
	real Zmod_HN(real alpha, real x, real y) {
		return pow(sqrt(square(x) + square(y)),-alpha);
	}
	real theta_HN(real alpha, real x, real y) {
		return -alpha*atan2(y,x);
	}
	// for DRT evaluation
	vector gamma_from_HN(vector tau, int M, real t0, real alpha, real beta) {
		vector[M] tt0 = tau ./ t0; //precalculate for efficiency
		vector[M] gamma_out;
		for (m in 1:M) {
			real theta = atan2(sin(pi()*beta),(pow(tt0[m],beta) + cos(pi()*beta)));
			gamma_out[m] = (1/pi())*pow(tt0[m],beta*alpha)*sin(alpha*theta)/pow(1+2*cos(pi()*beta)*pow(tt0[m],beta) + pow(tt0[m],2*beta),alpha/2);
		}
		return gamma_out;
	}
	// linear interpolation from https://discourse.mc-stan.org/t/linear-interpolation-and-searchsorted-in-stan/13318
	// modified to handle cases where x is outside x_pred range
	int which_min(vector y ){
		int ans = sort_indices_asc(y)[1];
		return(ans);
	  }
	real linear_interpolation(real x, vector x_pred, vector y_pred){
		int M = rows(x_pred);
		vector[M] deltas;
		real ans;
		int i;
		if(rows(y_pred) != M) reject("x_pred and y_pred aren't of the same size");
		deltas = fabs(x_pred - x);
		i = which_min(deltas);
		if (i == M && x < x_pred[i]){
			i = M - 1;
		}
		
		if (i == 1 && x <= x_pred[i]){
			ans = y_pred[i];
		}
		else if (i == M && x >= x_pred[i]){
			ans = y_pred[i];
		}
		else {
		  real x1 = x_pred[i];
		  real x2 = x_pred[i + 1];
		  real y1 = y_pred[i];
		  real y2 = y_pred[i + 1];
		  ans = y1 + (y2-y1) * (x-x1)/(x2-x1);
		}
		return(ans);
	}
}
data {
	// Dimensions
	int<lower=0> N; // number of measured frequencies
	int<lower=0> K; // number of DRT basis functions
	int<lower=0> J; // number of HN elements
	int<lower=0> M; // number of DRT evaluation points
	
	// Matrices
	matrix[N, K] A_re; // A*x = Z_hat
	matrix[N, K] A_im;
	matrix[M, K] G; // G*x = gamma
	matrix[K,K] L0; // 0th order differentiation matrix
	matrix[K,K] L1; // 1st order differentiation matrix
	matrix[K,K] L2; // 2nd order differentiation matrix
	
	// Impedance data
	vector[N] freq; //measured frequencies
	vector[2*N] Z; // stacked impedance vector
	
	// HN limits
	real<lower=0> min_tau_HN;
	real<lower=0> max_tau_HN;
	
	// DRT evaluation
	vector[M] tau_drt; // tau grid for DRT evaluation
	real<lower=0> sigma_F_scale;
	real<lower=0> sigma_F_min;
	real<lower=0> sigma_F_res_scale;
	real<lower=0> alpha_F_prop_scale;
	
	// Fixed hyperparameters
	real<lower=0> induc_scale; // inductance scale
	real<lower=0> ups_alpha; // shape for inverse gamma distribution on ups
	real<lower=0> ups_beta; // rate for inverse gamma distribution on ups
	real<lower=0> R_hn_lambda_alpha;
	real<lower=0> R_hn_lambda_beta;
	
	// Impedance error structure
	real<lower=0> sigma_min; // noise level floor
	real<lower=0> sigma_res_scale;
	real<lower=0> alpha_prop_scale;
	real<lower=0> alpha_re_scale;
	real<lower=0> alpha_im_scale;
	real<lower=0> sigma_hn_scale;
	
	//real<lower=0> F_tau_hn_const;
	//real<lower=0> R_hn_const;
	
}
transformed data {
	vector[N] omega = 2*freq*pi();
	real min_lntau_HN = log(min_tau_HN);
	real max_lntau_HN = log(max_tau_HN);
}
parameters {
	// Impedance offsets
	real<lower=0> Rinf_raw;
	real<lower=0> induc_raw;
	
	// DRT
	vector<lower=0>[K] x_drt;
	vector<lower=0>[K] ups_raw;
	real<lower=0> d0_strength;
	real<lower=0> d1_strength;
	real<lower=0> d2_strength;
	
	// HN elements
	vector<lower=0>[J] R_hn;
	vector<lower=0>[J] R_hn_lambda;
	vector<lower=min_lntau_HN,upper=max_lntau_HN>[J] lntau_hn;
	vector<lower=0,upper=1>[J] alpha_hn;
	vector<lower=0,upper=1>[J] beta_hn;
	
	// Impedance error structure
	real<lower=0> sigma_res_raw;
	real<lower=0> alpha_prop_raw;
	real<lower=0> alpha_re_raw;
	real<lower=0> alpha_im_raw;
	
	real<lower=0> sigma_res_raw_drt;
	real<lower=0> alpha_prop_raw_drt;
	real<lower=0> alpha_re_raw_drt;
	real<lower=0> alpha_im_raw_drt;
	
	// HN-DRT concordance
	real<lower=0> sigma_F_res_raw;
	real<lower=0> alpha_F_prop_raw;
	
}
transformed parameters {
	// Direct calculations
	// =========================
	// Impedance offsets
	real<lower=0> Rinf = Rinf_raw*100;
	real<lower=0> induc = induc_raw*induc_scale;
	
	// DRT complexity
	vector<lower=0>[K] q = sqrt(d0_strength*square(L0*x_drt) + d1_strength*square(L1*x_drt) + d2_strength*square(L2*x_drt));
	vector<lower=0>[K] ups = ups_raw * 0.15;
	
	// Impedance error structure
	real<lower=0> sigma_res = sigma_res_raw*sigma_res_scale;
	real<lower=0> alpha_prop = alpha_prop_raw*alpha_prop_scale;
	real<lower=0> alpha_re = alpha_re_raw*alpha_re_scale;
	real<lower=0> alpha_im = alpha_im_raw*alpha_im_scale;
	
	real<lower=0> sigma_res_drt = sigma_res_raw_drt*sigma_res_scale;
	real<lower=0> alpha_prop_hn = alpha_prop_raw_drt*alpha_prop_scale;
	real<lower=0> alpha_re_drt = alpha_re_raw_drt*alpha_re_scale;
	real<lower=0> alpha_im_drt = alpha_im_raw_drt*alpha_im_scale;
	
	// HN-DRT concordance scale parameters
	real<lower=0> sigma_F_res = sigma_F_res_raw*sigma_F_res_scale;
	real<lower=0> alpha_F_prop = alpha_F_prop_raw*alpha_F_prop_scale;
	
	// DRT impedance
	vector[N] Z_drt_re = A_re*x_drt + Rinf;
	vector[N] Z_drt_im = A_im*x_drt + omega*induc;
	vector[2*N] Z_drt = append_row(Z_drt_re,Z_drt_im);
	
	// Multi-part & dependent calculations
	// ===================================
	// Variable declarations
	vector[K-2] dups;
	vector[M] F_drt;
	vector[M] F_hn;
	//vector[J] F_tau_hn;
	vector[M] F_mean;
	vector[M] sigma_F;
	vector[N] Z_hn_re;
	vector[N] Z_hn_im;
	vector[2*N] Z_hn;
	vector<lower=0>[2*N] sigma_drt;
	vector<lower=0>[2*N] sigma_hn;
	
	
	// Variation in DRT complexity scale (upsilon)
	for (k in 1:K-2)
		dups[k] = 0.5*(ups[k+1] - 0.5*(ups[k] + ups[k+2]))/ups[k+1];
		
	// HN-DRT concordance
	F_drt = G*x_drt;
	F_hn = rep_vector(0,M);
	for (j in 1:J){
		F_hn += R_hn[j]*gamma_from_HN(tau_drt, M, exp(lntau_hn[j]), alpha_hn[j], beta_hn[j]);
		//F_tau_hn[j] =  linear_interpolation(exp(lntau_hn[j]),tau_drt,F_drt);
	}
	F_mean = (F_drt + F_hn)/2;
	sigma_F = sigma_F_scale*sqrt(square(sigma_F_min) + square(sigma_F_res) + alpha_F_prop*F_mean);
	
	// Calculate HN impedance
	Z_hn_re = rep_vector(0,N);
	Z_hn_im = rep_vector(0,N);
	for (j in 1:J){
		real tau_hn = exp(lntau_hn[j]);
		for (n in 1:N){
			real x = HN_x(omega[n],tau_hn,beta_hn[j]);
			real y = HN_y(omega[n],tau_hn,beta_hn[j]);
			real Zmod = Zmod_HN(alpha_hn[j],x,y);
			real theta = theta_HN(alpha_hn[j],x,y);
			Z_hn_re[n] += R_hn[j]*Zmod*cos(theta);
			Z_hn_im[n] += R_hn[j]*Zmod*sin(theta);
		}
	}
	
	Z_hn_re += Rinf;
	Z_hn_im += induc*omega;
	Z_hn = append_row(Z_hn_re,Z_hn_im);
	
	// Calculate impedance error
	sigma_drt = sqrt(
		square(sigma_min) 
		+ square(sigma_res) 
		+ square(alpha_prop*Z_drt)
		+ square(alpha_re*append_row(Z_drt_re,Z_drt_re)) 
		+ square(alpha_im*append_row(Z_drt_im,Z_drt_im))
	);
	
	sigma_hn = sigma_hn_scale*sqrt(
		square(sigma_min) 
		+ square(sigma_res) 
		+ square(alpha_prop*Z_hn)
		+ square(alpha_re*append_row(Z_drt_re,Z_hn_re)) 
		+ square(alpha_im*append_row(Z_drt_im,Z_hn_im))
	);

}
model {
	// Impedance offsets
	Rinf_raw ~ std_normal();
	induc_raw ~ std_normal();
	
	// DRT complexity
	d0_strength ~ inv_gamma(5,5);
	d1_strength ~ inv_gamma(5,5);
	d2_strength ~ inv_gamma(5,5);
	ups_raw ~ inv_gamma(ups_alpha,ups_beta);
	dups ~ std_normal();
	q ~ normal(0,ups);
	
	// HN magnitude
	R_hn_lambda ~ gamma(R_hn_lambda_alpha,R_hn_lambda_beta);
	R_hn ~ exponential(R_hn_lambda);
	
	// HN-DRT concordance
	F_hn - F_drt ~ normal(0,sigma_F);
	sigma_F_res_raw ~ std_normal();
	alpha_F_prop_raw ~ std_normal();
	
	// Impedance error
	Z ~ normal(Z_drt,sigma_drt);
	Z ~ normal(Z_hn,sigma_hn);
	sigma_res_raw ~ std_normal();
	alpha_prop_raw ~ std_normal();
	alpha_re_raw ~ std_normal();
	alpha_im_raw ~ std_normal();
	
	//for (j in 1:J){
	//	target += log((F_tau_hn[j]+F_tau_hn_const)/(R_hn[j]+R_hn_const));
	//}
	
}