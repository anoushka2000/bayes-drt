functions {
	real HN_x(real omega, real tau0, real beta) {
		// Intermediate "x" variable
		return 1+ pow(omega*tau0,beta)*cos(beta*pi()/2);
	}
	real HN_y(real omega, real tau0, real beta){
		// Intermediate "y" variable
		return pow(omega*tau0,beta)*sin(beta*pi()/2);
	}
	real Zmod_HN(real alpha, real x, real y) {
		return pow(sqrt(square(x) + square(y)),-alpha);
	}
	real theta_HN(real alpha, real x, real y) {
		return -alpha*atan2(y,x);
	}
}
data {
	int<lower=0> N; // 2*number of measured frequencies
	int<lower=0> K; // number of HN basis functions
	vector[N] Z; // stacked impedance vector ([Z' Z'']^T)
	vector[N/2] freq; //measured frequencies
	real<lower=0> sigma_min; // noise level floor
	real<lower=0> induc_scale; // inductance scale
	real<lower=0> min_tau_HN; // lower bound on HN time constants
	real<lower=0> max_tau_HN; // upper bound on HN time constants
	real<lower=0> R_inv_scale;
}
transformed data {
	vector [N/2] omega = freq*2*pi();
	real min_lntau_HN = log(min_tau_HN);
	real max_lntau_HN = log(max_tau_HN);
}
parameters {
	real<lower=0> Rinf_raw;
	real<lower=0> induc_raw;
	// HN parameters
	vector<lower=0>[K] R_HN;
	vector<lower=min_lntau_HN,upper=max_lntau_HN>[K] lntau_HN;
	vector<lower=0,upper=1>[K] alpha_HN;
	vector<lower=0,upper=1>[K] beta_HN;
	
	real<lower=0> sigma_res_raw;
	real<lower=0> alpha_prop_raw;
	real<lower=0> alpha_re_raw;
	real<lower=0> alpha_im_raw;
	
}
transformed parameters {
	real<lower=0> Rinf = Rinf_raw*100;
	real<lower=0> induc = induc_raw*induc_scale;
	real<lower=0> sigma_res = sigma_res_raw*0.05;
	real<lower=0> alpha_prop = alpha_prop_raw*0.05;
	real<lower=0> alpha_re = alpha_re_raw*0.05;
	real<lower=0> alpha_im = alpha_im_raw*0.05;
	vector[N] Z_hat;
	vector[N/2] Z_hat_re = rep_vector(0,N/2);
	vector[N/2] Z_hat_im = rep_vector(0,N/2);
	vector<lower=0>[N] sigma_tot; 
	
	// calculate Z_hat
	for (k in 1:K){
		real tau_HN = exp(lntau_HN[k]);
		for (n in 1:N/2){
			real x = HN_x(omega[n],tau_HN,beta_HN[k]);
			real y = HN_y(omega[n],tau_HN,beta_HN[k]);
			real Zmod = Zmod_HN(alpha_HN[k],x,y);
			real theta = theta_HN(alpha_HN[k],x,y);
			Z_hat_re[n] += R_HN[k]*Zmod*cos(theta);
			Z_hat_im[n] += R_HN[k]*Zmod*sin(theta);
		}
	}
	
	Z_hat_re += Rinf;
	Z_hat_im += induc*omega;
	Z_hat = append_row(Z_hat_re,Z_hat_im);
	
	// calculate error scale
	sigma_tot = sqrt(square(sigma_min) + square(sigma_res) + square(alpha_prop*Z_hat)
									+ square(alpha_re*append_row(Z_hat_re,rep_vector(0,N/2))) 
									+ square(alpha_im*append_row(rep_vector(0,N/2),Z_hat_im))
									);
}
model {
	R_HN ~ exponential(R_inv_scale);
	Rinf_raw ~ std_normal();
	induc_raw ~ std_normal();
	
	Z ~ normal(Z_hat,sigma_tot);
	sigma_res_raw ~ std_normal();
	alpha_prop_raw ~ std_normal();
	alpha_re_raw ~ std_normal();
	alpha_im_raw ~ std_normal();
}