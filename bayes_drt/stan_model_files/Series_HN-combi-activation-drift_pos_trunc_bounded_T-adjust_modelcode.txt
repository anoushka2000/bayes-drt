functions {
	// for impedance calculation
	real HN_x(real omega, real tau0, real beta) {
		// Intermediate "x" variable
		return 1+ pow(omega*tau0,beta)*cos(beta*pi()/2);
	}
	real HN_y(real omega, real tau0, real beta){
		// Intermediate "y" variable
		return pow(omega*tau0,beta)*sin(beta*pi()/2);
	}
	real Zmod_HN(real alpha, real x, real y) {
		return pow(sqrt(square(x) + square(y)),-alpha);
	}
	real theta_HN(real alpha, real x, real y) {
		return -alpha*atan2(y,x);
	}
	
	// for drift calculations
	real R_drift(real R_i, real R_f, real k_d, real time) {
		return R_i + (R_f - R_i)*(1 - exp(-k_d*time));
	}
	real tau_drift(real tau_i, real R_i, real R_f, real k_d, real phi_d, real time) {
		return tau_i + tau_i*(pow(R_f/R_i,phi_d) - 1)*(1 - exp(-k_d*time)); 
	}
	
	// for matrix formatting
	vector upper_triangle_to_vec(matrix m, int K) {
		// Get upper triangle of matrix and flatten
		// matrix m should be [K,K]
		vector[K*(K-1)/2] x;
		int pos = 1;
		for (i in 1:K) {
			for (j in i+1:K) {
				x[pos] = m[i,j];
				pos += 1;
			}
		}
		return x;
	}
	
	
	// Arrhenius functions
	real k_B() {
		// Boltzmann constant (eV/K)
		return 8.617333e-5; 
	} 
	real arrhenius(real temp, real T_base, real dG, real y_base) {
		return y_base*exp((dG/k_B())*(1/temp - 1/T_base));
	}
	
}
data {
	// dimensions
	int<lower=0> J; // number of contacts
	int<lower=0> N; // number of measured frequencies
	int<lower=0> K; // number of HN basis functions
	int<lower=0> M; // number of pairwise comparisons to keep
	int<lower=0> P; // number of distinct temperatures
	
	// spatial coordinates
	vector[J] x_coord;
	vector[J] y_coord;
	
	// impedance data
	matrix[J,N] freq; // measured frequencies
	matrix[J,N] times; // measurement times
	matrix[J,2*N] Z; // stacked impedance vector ([Z' Z'']^T)
	vector<lower=0>[N] rel_Z_scale;
	
	// temperature
	matrix[J,N] temp; // measurement temperatures (K)
	real<lower=0> T_base; // base temperature (K)
	int temp_start_indices[P-1]; // indices of new temperature starts (excluding 1st temperature)
	real<lower=0> temp_uncertainty; // maximum temperature offset
	real<lower=0> temp_offset_scale; // scale for normal prior on temp_offset
	
	// for distance_vec truncation
	int compare_idx[M]; // indexes of distance_vec to keep for parameter comparison
	
	// fixed hyperparameters
	// --------------------
	real<lower=0> sigma_min; // noise level floor
	real<lower=0> induc_scale; // inductance scale
	real<lower=0> max_delta_G; // upper bound on activation energy
	real<lower=0> ups_alpha; 
	real<lower=0> ups_beta;
	
	real<lower=0> min_k;
	real<lower=0> max_k;
	
	// inverse gamma prior on deltaR_base
	real<lower=0> deltaR_scale_alpha;
	real<lower=0> deltaR_scale_beta;
	
	// scales of spatial standard deviations
	real<lower=0> sigmaxy_lntau_scale;
	real<lower=0> sigmaxy_lnRi_scale;
	real<lower=0> sigmaxy_alpha_scale;
	real<lower=0> sigmaxy_beta_scale;
	real<lower=0> sigmaxy_deltaG_scale;
	real<lower=0> sigmaxy_lnphiT_scale;
	
	real<lower=0> sigmaxy_lnRf_scale;
	real<lower=0> sigmaxy_lnk_scale;
	real<lower=0> sigmaxy_deltaGk_scale;
	real<lower=0> sigmaxy_lnphid_scale;
	
	real<lower=0> sigmaxy_tempoffset_scale;
	
	// scales of ln_phi
	real<lower=0> ln_phi_T_scale;
	real<lower=0> ln_phi_d_scale;
	
	
}
transformed data {
	matrix [J,N] omega = freq*2*pi();
	vector[2*N] rel_Z_scale_stack = append_row(rel_Z_scale,rel_Z_scale);
	
	// Construct distance matrix and vector
	matrix[J,J] dx_mat = rep_matrix(x_coord,J) - rep_matrix(x_coord,J)';
	matrix[J,J] dy_mat = rep_matrix(y_coord,J) - rep_matrix(y_coord,J)';
	matrix[J,J] D = sqrt(square(dx_mat) + square(dy_mat));
	vector[J*(J-1)/2] distance_vec_full = upper_triangle_to_vec(D,J);
	vector[M] distance_vec = distance_vec_full[compare_idx];
	
	real min_lnk = log(min_k);
	real max_lnk = log(max_k);
	int temp_end_indices[P-1];
	for (p in 1:P-2) {
		temp_end_indices[p] = temp_start_indices[p+1] - 1;
	}
	temp_end_indices[P-1] = N;
}
parameters {
	// offsets
	vector<lower=0>[J] Rinf_base_raw;
	vector<lower=0>[J] induc_raw;
	
	// L1 regularization strength
	vector<lower=0>[K] upsilon;
	
	// HN parameters
	matrix<lower=0>[J,K] R_i_base;
	ordered[K] lntau_i_base[J];
	matrix<lower=0,upper=1>[J,K] alpha_HN;
	matrix<lower=0,upper=1>[J,K] beta_HN;
	
	// drift parameters
	matrix[J,K] deltaR_base_raw;
	matrix<lower=min_lnk,upper=max_lnk>[J,K] ln_k_base; // ln of rate constant for drift at T_base
	matrix<lower=0>[J,K] delta_G_k;
	matrix[J,K] ln_phi_d_raw;
	row_vector[K] deltaR_base_scale;
	
	// Arrhenius parameters
	vector<lower=0,upper=max_delta_G>[J] delta_G_Rinf; // activation energy for Rinf
	matrix<lower=0,upper=max_delta_G>[J,K] delta_G; // activation energy for R_HN
	matrix[J,K] ln_phi_T_raw; // ln of activation energy factor for tau
	matrix<lower=-temp_uncertainty/temp_offset_scale,upper=temp_uncertainty/temp_offset_scale>[J,P-1] temp_offset_raw; // no entry for 1st temp - keep fixed
	
	// spatial parameter difference scales
	vector<lower=0>[K] sigmaxy_lntau_raw;
	vector<lower=0>[K] sigmaxy_lnRi_raw;
	vector<lower=0>[K] sigmaxy_alpha_raw;
	vector<lower=0>[K] sigmaxy_beta_raw;
	vector<lower=0>[K] sigmaxy_deltaG_raw;
	vector<lower=0>[K] sigmaxy_lnphiT_raw;
	
	vector<lower=0>[K] sigmaxy_lnRf_raw;
	vector<lower=0>[K] sigmaxy_lnk_raw;
	vector<lower=0>[K] sigmaxy_deltaGk_raw;
	vector<lower=0>[K] sigmaxy_lnphid_raw;
	
	vector<lower=0>[P-1] sigmaxy_tempoffset_raw;
	
	// error structure parameters
	real<lower=0> sigma_res_raw;
	real<lower=0> alpha_prop_raw;
	real<lower=0> alpha_re_raw;
	real<lower=0> alpha_im_raw;
}
transformed parameters {
	// offsets
	vector<lower=0>[J] Rinf_base = Rinf_base_raw*100;
	vector<lower=0>[J] induc = induc_raw*induc_scale;
	
	// drift parameters
	matrix[J,K] deltaR_base = deltaR_base_raw .* rep_matrix(deltaR_base_scale,J);
	matrix[J,K] ln_phi_d = ln_phi_d_raw*ln_phi_d_scale;
	matrix[J,K] R_f_base = R_i_base + deltaR_base;
	
	// Arrhenius parameters
	matrix[J,K] ln_phi_T = ln_phi_T_raw*ln_phi_T_scale;
	matrix<lower=-temp_uncertainty,upper=temp_uncertainty>[J,P-1] temp_offset = temp_offset_raw*temp_offset_scale;
	matrix[J,N] temp_actual;
	
	// parameter std deviations
	vector<lower=0>[K] sigmaxy_lntau = sigmaxy_lntau_raw*sigmaxy_lntau_scale;
	vector<lower=0>[K] sigmaxy_lnRi = sigmaxy_lnRi_raw*sigmaxy_lnRi_scale;
	vector<lower=0>[K] sigmaxy_alpha = sigmaxy_alpha_raw*sigmaxy_alpha_scale;
	vector<lower=0>[K] sigmaxy_beta = sigmaxy_beta_raw*sigmaxy_beta_scale;
	vector<lower=0>[K] sigmaxy_deltaG = sigmaxy_deltaG_raw*sigmaxy_deltaG_scale;
	vector<lower=0>[K] sigmaxy_lnphiT = sigmaxy_lnphiT_raw*sigmaxy_lnphiT_scale;
	
	vector<lower=0>[K] sigmaxy_lnRf = sigmaxy_lnRf_raw*sigmaxy_lnRf_scale;
	vector<lower=0>[K] sigmaxy_lnk = sigmaxy_lnk_raw*sigmaxy_lnk_scale;
	vector<lower=0>[K] sigmaxy_deltaGk = sigmaxy_deltaGk_raw*sigmaxy_deltaGk_scale;
	vector<lower=0>[K] sigmaxy_lnphid = sigmaxy_lnphid_raw*sigmaxy_lnphid_scale;
	
	vector<lower=0>[P-1] sigmaxy_tempoffset = sigmaxy_tempoffset_raw*sigmaxy_tempoffset_scale;
	
	// error structure parameters
	real<lower=0> sigma_res = sigma_res_raw*0.05;
	real<lower=0> alpha_prop = alpha_prop_raw*0.01;
	real<lower=0> alpha_re = alpha_re_raw*0.01;
	real<lower=0> alpha_im = alpha_im_raw*0.01;
	
	// parameter difference arrays
	vector[M] diff_lntau[K];
	vector[M] diff_lnRi[K];
	vector[M] diff_alpha[K];
	vector[M] diff_beta[K];
	vector[M] diff_deltaG[K];
	vector[M] diff_lnphiT[K];
	
	vector[M] diff_lnRf[K];
	vector[M] diff_lnk[K];	
	vector[M] diff_deltaGk[K];
	vector[M] diff_lnphid[K];
	
	vector[M] diff_tempoffset[P-1];
	
	// calculated impedance
	vector[2*N] Z_hat[J];
	vector[N] Z_hat_re[J];
	vector[N] Z_hat_im[J];
	vector<lower=0>[2*N] sigma_tot[J]; 
	
	// calculate actual temp
	temp_actual[ ,1:temp_start_indices[1]] = temp[ ,1:temp_start_indices[1]]; //first temp is fixed
	for (p in 1:P-1) {
		temp_actual[ ,temp_start_indices[p]:temp_end_indices[p]] = temp[ ,temp_start_indices[p]:temp_end_indices[p]] 
																   + rep_matrix(temp_offset[ ,p],temp_end_indices[p] +1 - temp_start_indices[p]);
	}
	
	// calculate Z_hat
	for (j in 1:J){
		Z_hat_re[j] = rep_vector(0,N);
		Z_hat_im[j] = rep_vector(0,N);
		for (k in 1:K){
			real phi_T = exp(ln_phi_T[j,k]);
			
			for (n in 1:N){
				// calculate R_i, R_f, tau_i, and k_d at temp
				real R_i = arrhenius(temp_actual[j,n],T_base,delta_G[j,k],R_i_base[j,k]);
				real R_f = arrhenius(temp_actual[j,n],T_base,delta_G[j,k],R_f_base[j,k]);
				real tau_i = arrhenius(temp_actual[j,n],T_base,phi_T*delta_G[j,k],exp(lntau_i_base[j,k]));
				real k_d = arrhenius(temp_actual[j,n],T_base,-delta_G_k[j,k],exp(ln_k_base[j,k]));
				
				// calculate R(t) and tau(t) at time
				real R_t = R_drift(R_i, R_f, k_d, times[j,n]);
				real tau_t = tau_drift(tau_i, R_i, R_f, k_d, exp(ln_phi_d[j,k]), times[j,n]);
				
				// temp-dependent R and tau feed into Z_hat calcs
				real x = HN_x(omega[j,n],tau_t,beta_HN[j,k]);
				real y = HN_y(omega[j,n],tau_t,beta_HN[j,k]);
				real Zmod = Zmod_HN(alpha_HN[j,k],x,y);
				real theta = theta_HN(alpha_HN[j,k],x,y);
				Z_hat_re[j,n] += R_t*Zmod*cos(theta);
				Z_hat_im[j,n] += R_t*Zmod*sin(theta);
			}
		}
		Z_hat_re[j] += (Rinf_base[j]*exp((delta_G_Rinf[j]/k_B())*(1 ./temp_actual[j] - 1/T_base)))';
		Z_hat_im[j] += induc[j]*omega[j]';
		Z_hat[j] = append_row(Z_hat_re[j],Z_hat_im[j]);
	}
	
	// calculate parameter differences
	for (k in 1:K) {
		vector[J] lntau_k = to_vector(lntau_i_base[ ,k]);
		vector[J] lnRi_k = log(R_i_base[ ,k]);
		vector[J] alpha_k = alpha_HN[ ,k];
		vector[J] beta_k = beta_HN[ ,k];
		vector[J] deltaG_k = delta_G[ ,k];
		vector[J] lnphiT_k = ln_phi_T[ ,k];
		vector[J] lnRf_k = log(R_f_base[ ,k]);
		vector[J] lnk_k = ln_k_base[ ,k];
		vector[J] deltaGk_k = delta_G_k[ ,k];
		vector[J] lnphid_k = ln_phi_d[ ,k];
		
		matrix[J,J] dlntau_k = rep_matrix(lntau_k,J) - rep_matrix(lntau_k,J)';
		matrix[J,J] dlnRi_k = rep_matrix(lnRi_k,J) - rep_matrix(lnRi_k,J)';
		matrix[J,J] dalpha_k = rep_matrix(alpha_k,J) - rep_matrix(alpha_k,J)';
		matrix[J,J] dbeta_k = rep_matrix(beta_k,J) - rep_matrix(beta_k,J)';
		matrix[J,J] ddeltaG_k = rep_matrix(deltaG_k,J) - rep_matrix(deltaG_k,J)';
		matrix[J,J] dlnphiT_k = rep_matrix(lnphiT_k,J) - rep_matrix(lnphiT_k,J)';
		matrix[J,J] dlnRf_k = rep_matrix(lnRf_k,J) - rep_matrix(lnRf_k,J)';
		matrix[J,J] dlnk_k = rep_matrix(lnk_k,J) - rep_matrix(lnk_k,J)';
		matrix[J,J] ddeltaGk_k = rep_matrix(deltaGk_k,J) - rep_matrix(deltaGk_k,J)';
		matrix[J,J] dlnphid_k = rep_matrix(lnphid_k,J) - rep_matrix(lnphid_k,J)';
		
		vector[J*(J-1)/2] diff_lntau_full = upper_triangle_to_vec(dlntau_k,J);
		vector[J*(J-1)/2] diff_lnRi_full = upper_triangle_to_vec(dlnRi_k,J);
		vector[J*(J-1)/2] diff_alpha_full = upper_triangle_to_vec(dalpha_k,J);
		vector[J*(J-1)/2] diff_beta_full = upper_triangle_to_vec(dbeta_k,J);
		vector[J*(J-1)/2] diff_deltaG_full = upper_triangle_to_vec(ddeltaG_k,J);
		vector[J*(J-1)/2] diff_lnphiT_full = upper_triangle_to_vec(dlnphiT_k,J);
		vector[J*(J-1)/2] diff_lnRf_full = upper_triangle_to_vec(dlnRf_k,J);
		vector[J*(J-1)/2] diff_lnk_full = upper_triangle_to_vec(dlnk_k,J);
		vector[J*(J-1)/2] diff_deltaGk_full = upper_triangle_to_vec(ddeltaGk_k,J);
		vector[J*(J-1)/2] diff_lnphid_full = upper_triangle_to_vec(dlnphid_k,J);
		
		diff_lntau[k] = diff_lntau_full[compare_idx] ./ (distance_vec*sigmaxy_lntau[k]);
		diff_lnRi[k] = diff_lnRi_full[compare_idx] ./ (distance_vec*sigmaxy_lnRi[k]);
		diff_alpha[k] = diff_alpha_full[compare_idx] ./ (distance_vec*sigmaxy_alpha[k]);
		diff_beta[k] = diff_beta_full[compare_idx] ./ (distance_vec*sigmaxy_beta[k]);
		diff_deltaG[k] = diff_deltaG_full[compare_idx] ./ (distance_vec*sigmaxy_deltaG[k]);
		diff_lnphiT[k] = diff_lnphiT_full[compare_idx] ./ (distance_vec*sigmaxy_lnphiT[k]);
		diff_lnRf[k] = diff_lnRf_full[compare_idx] ./ (distance_vec*sigmaxy_lnRf[k]);
		diff_lnk[k] = diff_lnk_full[compare_idx] ./ (distance_vec*sigmaxy_lnk[k]);
		diff_deltaGk[k] = diff_deltaGk_full[compare_idx] ./ (distance_vec*sigmaxy_deltaGk[k]);
		diff_lnphid[k] = diff_lnphid_full[compare_idx] ./ (distance_vec*sigmaxy_lnphid[k]);
	}
	
	for (p in 1:P-1) {
		vector[J] tempoffset_p = temp_offset[ ,p];
		matrix[J,J] dtempoffset_p = rep_matrix(tempoffset_p,J) - rep_matrix(tempoffset_p,J)';
		vector[J*(J-1)/2] diff_tempoffset_full = upper_triangle_to_vec(dtempoffset_p,J);
		diff_tempoffset[p] = diff_tempoffset_full[compare_idx] ./ (distance_vec*sigmaxy_tempoffset[p]);
		
	}
	
	// calculate error scale
	for (j in 1:J) {
		sigma_tot[j] = sqrt(square(sigma_min*rel_Z_scale_stack) + square(sigma_res*rel_Z_scale_stack) + square(alpha_prop*Z_hat[j])
									+ square(alpha_re*append_row(Z_hat_re[j],Z_hat_re[j])) 
									+ square(alpha_im*append_row(Z_hat_im[j],Z_hat_im[j]))
									);
	}
}
model {
	upsilon ~ gamma(ups_alpha,ups_beta);
	for (j in 1:J) {
		R_i_base[j] ~ exponential(upsilon);
	}
	
	// offsets
	Rinf_base_raw ~ std_normal();
	induc_raw ~ std_normal();
	
	// drift parameters
	deltaR_base_scale ~ inv_gamma(deltaR_scale_alpha,deltaR_scale_beta);
	for (j in 1:J) {
		deltaR_base_raw[j] ~ std_normal();
		ln_phi_d_raw[j] ~ std_normal();
	}
	
	
	// Arrhenius parameters
	for (j in 1:J) {
		ln_phi_T_raw[j] ~ std_normal();
		temp_offset_raw[j] ~ std_normal();
	}
	
	// parameter differences
	for (k in 1:K) {
		diff_lntau[k] ~ std_normal();
		diff_lnRi[k] ~ std_normal();
		diff_alpha[k] ~ std_normal();
		diff_beta[k] ~ std_normal();
		diff_deltaG[k] ~ std_normal();
		diff_lnphiT[k] ~ std_normal();
		diff_lnRf[k] ~ std_normal();
		diff_lnk[k] ~ std_normal();	
		diff_deltaGk[k] ~ std_normal();
		diff_lnphid[k] ~ std_normal();
	}
	
	for (p in 1:P-1) {
		diff_tempoffset[p] ~ std_normal();
	}
	
	// parameter std deviations
	sigmaxy_lntau_raw ~ std_normal();
	sigmaxy_lnRi_raw ~ std_normal();
	sigmaxy_alpha_raw ~ std_normal();
	sigmaxy_beta_raw ~ std_normal();
	sigmaxy_deltaG_raw ~ std_normal();
	sigmaxy_lnphiT_raw ~ std_normal();
	
	sigmaxy_lnRf_raw ~ std_normal();
	sigmaxy_lnk_raw ~ std_normal();
	sigmaxy_deltaGk_raw ~ std_normal();
	sigmaxy_lnphid_raw ~ std_normal();
	
	sigmaxy_tempoffset_raw ~ std_normal();
	
	// impedance
	for (j in 1:J) {
		Z[j] ~ normal(Z_hat[j],sigma_tot[j]);
	}
	
	// error structure
	sigma_res_raw ~ std_normal();
	alpha_prop_raw ~ std_normal();
	alpha_re_raw ~ std_normal();
	alpha_im_raw ~ std_normal();
}