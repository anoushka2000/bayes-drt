// assume timescale for changes to x is larger than measurement timescale
// Use linear approximation for exponential time dependence
data {
	int<lower=0> N; // number of measured frequencies
	int<lower=0> K; // number of basis functions
	// int<lower=0> S; // number of spectra
	matrix[N, K] A; // stacked A matrix ([[A'] [A'']])
	vector[N] Z; // stacked impedance vector ([Z' Z'']^T)
	vector[N/2] freq; // measured frequencies
	vector[N/2] time; // measurement times
	int<lower=0> N_tilde; // number of frequencies to predict
	matrix[N_tilde,K] A_tilde; //stacked A matrix for prediction
	vector[N_tilde/2] freq_tilde; // frequencies to predict
	matrix[K,K] L0; // 0th order differentiation matrix
	matrix[K,K] L1; // 1st order differentiation matrix
	matrix[K,K] L2; // 2nd order differentiation matrix
	real<lower=0> sigma_min; // noise level floor
	real<lower=0> ups_alpha; // shape for inverse gamma distribution on ups
	real<lower=0> ups_beta; // rate for inverse gamma distribution on ups
	real<lower=0> induc_scale;
	real<lower=0> dx_scale_fixed;
}
transformed data {
	// vector [N] Rinf_vec = append_row(rep_vector(1,N/2), rep_vector(0,N/2));
	vector [N] induc_vec = append_row(rep_vector(0,N/2), 2*pi()*freq);
	vector [N_tilde] Rinf_vec_tilde = append_row(rep_vector(1,N_tilde/2), rep_vector(0,N_tilde/2));
	vector [N_tilde] induc_vec_tilde = append_row(rep_vector(0,N_tilde/2), 2*pi()*freq_tilde);
	matrix[K,N] T = rep_matrix(append_col(time',time'), K);
	matrix[K,N] Ft = T ./ max(time); // Relative dx magnitude as function of time (matrix). Linear approximation
	vector[N/2] ft = time ./ max(time); // Relative dx magnitude as function of time (vector). Linear approximation
}
parameters {
	real<lower=0> Rinf0_raw;
	real<lower=0> induc_raw;
	vector[K] x0;
	vector[K] dx;
	real<lower=0> sigma_res_raw;
	real<lower=0> alpha_prop_raw;
	real<lower=0> alpha_re_raw;
	real<lower=0> alpha_im_raw;
	vector<lower=0>[K] ups_x0_raw;
	vector<lower=0>[K] ups_dx_raw;
	real<lower=0> d0_strength_x0;
	real<lower=0> d1_strength_x0;
	real<lower=0> d2_strength_x0;
	real<lower=0> d0_strength_dx;
	real<lower=0> d1_strength_dx;
	real<lower=0> d2_strength_dx;
	//real<lower=0> dx_scale_raw;
	real<lower=-100*Rinf0_raw> delta_Rinf; // change in R_inf. Cannot result in negative R_inf
}
transformed parameters {
	//real<lower=0> dx_scale = dx_scale_raw*dx_scale_fixed;
	// construct time-dependent coefficient matrix, X
	matrix[K,N] X0 = rep_matrix(x0,N); 
	matrix[K,N] DX = rep_matrix(dx,N);
	matrix[K,N] X = X0 + dx_scale_fixed * DX .* Ft;
	// calculate elementwise product of A and X'
	matrix[N,K] AX = A .* X';
	
	// calculate time-dependent Rinf vector
	vector[N] Rinf = append_row(
								100*Rinf0_raw + delta_Rinf*ft, // real part
								rep_vector(0,N/2) // imag part
								);
	// inductance (not time-dependent)
	real<lower=0> induc = induc_raw*induc_scale;
	
	// predicted impedance, Z_hat
	vector[N] Z_hat;
	vector[N] Z_hat_re; 
	vector[N] Z_hat_im; 
	
	// complexity functions
	vector<lower=0>[K] q_x0 = sqrt(d0_strength_x0*square(L0*x0) + d1_strength_x0*square(L1*x0) + d2_strength_x0*square(L2*x0));
	vector<lower=0>[K] q_dx = sqrt(d0_strength_dx*square(L0*dx) + d1_strength_dx*square(L1*dx) + d2_strength_dx*square(L2*dx));
	
	// error contributions
	real<lower=0> sigma_res = sigma_res_raw*0.05;
	real<lower=0> alpha_prop = alpha_prop_raw*0.05;
	real<lower=0> alpha_re = alpha_re_raw*0.05;
	real<lower=0> alpha_im = alpha_im_raw*0.05;
	vector<lower=0>[N] sigma_tot; 
									
	// upsilon and delta_upsilon
	vector<lower=0>[K] ups_x0 = ups_x0_raw * 0.15;
	vector<lower=0>[K] ups_dx = ups_dx_raw * 0.15;
	vector[K-2] dups_x0;
	vector[K-2] dups_dx;								
	
	// calculate Z_hat
	for (n in 1:N)
		Z_hat[n] = sum(row(AX,n));
	Z_hat += Rinf + induc*induc_vec;
	// separate real and imag parts for use in sigma_tot
	Z_hat_re = append_row(Z_hat[1:N/2],Z_hat[1:N/2]);
	Z_hat_im = append_row(Z_hat[N/2+1:N],Z_hat[N/2+1:N]);
	
	// calculate total error scale
	sigma_tot = sqrt(
						square(sigma_min) + square(sigma_res) + square(alpha_prop*Z_hat)
						+ square(alpha_re*Z_hat_re) + square(alpha_im*Z_hat_im)
					);
									
	// calculate delta_upsilon
	for (k in 1:K-2){
		dups_x0[k] = 0.5*(ups_x0[k+1] - 0.5*(ups_x0[k] + ups_x0[k+2]))/ups_x0[k+1];
		dups_dx[k] = 0.5*(ups_dx[k+1] - 0.5*(ups_dx[k] + ups_dx[k+2]))/ups_dx[k+1];
		}
}
model {
	d0_strength_x0 ~ inv_gamma(5,5);
	d1_strength_x0 ~ inv_gamma(5,5);
	d2_strength_x0 ~ inv_gamma(5,5);
	d0_strength_dx ~ inv_gamma(5,5);
	d1_strength_dx ~ inv_gamma(5,5);
	d2_strength_dx ~ inv_gamma(5,5);
	ups_x0_raw ~ inv_gamma(ups_alpha,ups_beta);
	ups_dx_raw ~ inv_gamma(ups_alpha,ups_beta);
	Rinf0_raw ~ std_normal();
	delta_Rinf ~ std_normal();
	induc_raw ~ std_normal();
	q_x0 ~ normal(0,ups_x0);
	q_dx ~ normal(0,ups_dx);
	dups_x0 ~ std_normal();
	dups_dx ~ std_normal();
	//dx_scale_raw ~ std_normal();
	Z ~ normal(Z_hat,sigma_tot);
	sigma_res_raw ~ std_normal();
	alpha_prop_raw ~ std_normal();
	alpha_re_raw ~ std_normal();
	alpha_im_raw ~ std_normal();
}
// generated quantities {
// 	vector[N_tilde] Z_hat_tilde
// 		= A_tilde*x + Rinf*Rinf_vec_tilde + induc*induc_vec_tilde;
// }