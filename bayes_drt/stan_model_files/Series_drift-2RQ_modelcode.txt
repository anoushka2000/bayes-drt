data {
	int<lower=0> N; // number of measured frequencies
	int<lower=0> K; // number of basis functions
	// int<lower=0> S; // number of spectra
	matrix[N, K] A; // stacked A matrix ([[A'] [A'']])
	vector[N] Z; // stacked impedance vector ([Z' Z'']^T)
	vector[N/2] freq; // measured frequencies
	vector[N/2] time; // measurement times
	int<lower=0> N_tilde; // number of frequencies to predict
	matrix[N_tilde,K] A_tilde; //stacked A matrix for prediction
	vector[N_tilde/2] freq_tilde; // frequencies to predict
	matrix[K,K] L0; // 0th order differentiation matrix
	matrix[K,K] L1; // 1st order differentiation matrix
	matrix[K,K] L2; // 2nd order differentiation matrix
	real<lower=0> sigma_min; // noise level floor
	real<lower=0> ups_alpha; // shape for inverse gamma distribution on ups
	real<lower=0> ups_beta; // rate for inverse gamma distribution on ups
	real<lower=0> induc_scale;
	real min_tau_rq1;
	real max_tau_rq1;
	real min_tau_rq2;
	real max_tau_rq2;
	//real min_tau_Rinf;
	//real max_tau_Rinf;
}
transformed data {
	vector [N/2] omega = 2*pi()*freq;
	vector [N] induc_vec = append_row(rep_vector(0,N/2), omega);
	//vector [N_tilde] Rinf_vec_tilde = append_row(rep_vector(1,N_tilde/2), rep_vector(0,N_tilde/2));
	//vector [N_tilde] induc_vec_tilde = append_row(rep_vector(0,N_tilde/2), 2*pi()*freq_tilde);
	real min_log_tau_rq1 = log(min_tau_rq1);
	real max_log_tau_rq1 = log(max_tau_rq1);
	real min_log_tau_rq2 = log(min_tau_rq2);
	real max_log_tau_rq2 = log(max_tau_rq2);
	vector[N/2] Ft = time ./ max(time); // ZARC magnitude as function of time. Linear approximation
}
parameters {
	real<lower=0> Rinf0_raw;
	real<lower=0> induc_raw;
	vector[K] x0;
	real<lower=0> sigma_res_raw;
	real<lower=0> alpha_prop_raw;
	real<lower=0> alpha_re_raw;
	real<lower=0> alpha_im_raw;
	vector<lower=0>[K] ups_x0_raw;
	real<lower=0> d0_strength_x0;
	real<lower=0> d1_strength_x0;
	real<lower=0> d2_strength_x0;
	
	// time-dependent RQ elements
	real R_rq1; // change in polarization resistance
	real<lower=0,upper=1> phi_rq1; // phi parameter for time-dependent ZARC (RQ) element
	real<lower=min_log_tau_rq1,upper=max_log_tau_rq1> log_tau_rq1; // log time constant for time-dependent ZARC
	
	real R_rq2; // change in polarization resistance
	real<lower=0,upper=1> phi_rq2; // phi parameter for time-dependent ZARC (RQ) element
	real<lower=min_log_tau_rq2,upper=max_log_tau_rq2> log_tau_rq2; // log time constant for time-dependent ZARC
	
	real<lower=-100*Rinf0_raw> delta_Rinf; // change in R_inf. Cannot result in negative R_inf
}
transformed parameters {
	
	// inductance (not time-dependent)
	real<lower=0> induc = induc_raw*induc_scale;
	
	// time-dependent ZARC (RQ) contribution
	vector[N/2] Z_rq1_deno;
	vector[N/2] Z_rq1_re;
	vector[N/2] Z_rq1_im;
	vector[N] ZFt_rq1; // Z_rq1 times Ft
	
	vector[N/2] Z_rq2_deno;
	vector[N/2] Z_rq2_re;
	vector[N/2] Z_rq2_im;
	vector[N] ZFt_rq2; // Z_rq2 times Ft
	
	// predicted impedance, Z_hat
	vector[N] Z_hat;
	vector[N] Z_hat_re; 
	vector[N] Z_hat_im; 
	
	// calculate time-dependent Rinf vector
	vector[N] Rinf = append_row(
								100*Rinf0_raw + delta_Rinf*Ft, // real part
								rep_vector(0,N/2) // imag part
								);
	
	// complexity functions
	vector<lower=0>[K] q_x0 = sqrt(d0_strength_x0*square(L0*x0) + d1_strength_x0*square(L1*x0) + d2_strength_x0*square(L2*x0));
	
	// error contributions
	real<lower=0> sigma_res = sigma_res_raw*0.05;
	real<lower=0> alpha_prop = alpha_prop_raw*0.05;
	real<lower=0> alpha_re = alpha_re_raw*0.05;
	real<lower=0> alpha_im = alpha_im_raw*0.05;
	vector<lower=0>[N] sigma_tot; 
									
	// upsilon and delta_upsilon
	vector<lower=0>[K] ups_x0 = ups_x0_raw * 0.15;
	vector[K-2] dups_x0;

	// time constants
	real<lower=0> tau_rq1 = exp(log_tau_rq1);
	real<lower=0> tau_rq2 = exp(log_tau_rq2);

	// calculate time-dependent Z_rq contribution
	for (n in 1:N/2){
		Z_rq1_deno[n] = square(1+ pow(omega[n]*tau_rq1,phi_rq1)*cos(phi_rq1*pi()/2)) + square(pow(omega[n]*tau_rq1,phi_rq1)*sin(phi_rq1*pi()/2));
		Z_rq1_re[n] = (1 + pow(omega[n]*tau_rq1,phi_rq1)*cos(phi_rq1*pi()/2))/Z_rq1_deno[n];
		Z_rq1_im[n] = -(pow(omega[n]*tau_rq1,phi_rq1)*sin(phi_rq1*pi()/2))/Z_rq1_deno[n];
		
		Z_rq2_deno[n] = square(1+ pow(omega[n]*tau_rq2,phi_rq2)*cos(phi_rq2*pi()/2)) + square(pow(omega[n]*tau_rq2,phi_rq2)*sin(phi_rq2*pi()/2));
		Z_rq2_re[n] = (1 + pow(omega[n]*tau_rq2,phi_rq2)*cos(phi_rq2*pi()/2))/Z_rq2_deno[n];
		Z_rq2_im[n] = -(pow(omega[n]*tau_rq2,phi_rq2)*sin(phi_rq2*pi()/2))/Z_rq2_deno[n];
		}
		
	ZFt_rq1 = append_row(Z_rq1_re .* Ft, Z_rq1_im .* Ft);
	ZFt_rq1 *= R_rq1;	
	
	ZFt_rq2 = append_row(Z_rq2_re .* Ft, Z_rq2_im .* Ft);
	ZFt_rq2 *= R_rq2;	
	
	// calculate Z_hat
	Z_hat = A*x0; // initial (stable) DRT contribution
	Z_hat += Rinf + induc*induc_vec; // time-dependent Rinf and constant inductance contributions
	Z_hat += ZFt_rq1 + ZFt_rq2; // time-dependent ZARC contribution
		
	// separate real and imag parts for use in sigma_tot
	Z_hat_re = append_row(Z_hat[1:N/2],Z_hat[1:N/2]);
	Z_hat_im = append_row(Z_hat[N/2+1:N],Z_hat[N/2+1:N]);
	
	// calculate total error scale
	sigma_tot = sqrt(
						square(sigma_min) + square(sigma_res) + square(alpha_prop*Z_hat)
						+ square(alpha_re*Z_hat_re) + square(alpha_im*Z_hat_im)
					);
									
	// calculate delta_upsilon
	for (k in 1:K-2){
		dups_x0[k] = 0.5*(ups_x0[k+1] - 0.5*(ups_x0[k] + ups_x0[k+2]))/ups_x0[k+1];
		}
}
model {
	d0_strength_x0 ~ inv_gamma(5,5);
	d1_strength_x0 ~ inv_gamma(5,5);
	d2_strength_x0 ~ inv_gamma(5,5);
	ups_x0_raw ~ inv_gamma(ups_alpha,ups_beta);
	Rinf0_raw ~ std_normal();
	delta_Rinf ~ std_normal();
	induc_raw ~ std_normal();
	q_x0 ~ normal(0,ups_x0);
	dups_x0 ~ std_normal();
	Z ~ normal(Z_hat,sigma_tot);
	sigma_res_raw ~ std_normal();
	alpha_prop_raw ~ std_normal();
	alpha_re_raw ~ std_normal();
	alpha_im_raw ~ std_normal();
	log_tau_rq1 ~ uniform(min_log_tau_rq1,max_log_tau_rq1);
	log_tau_rq2 ~ uniform(min_log_tau_rq2,max_log_tau_rq2);
	R_rq1 ~ std_normal();
	R_rq2 ~ std_normal();
}
// generated quantities {
// 	vector[N_tilde] Z_hat_tilde
// 		= A_tilde*x + Rinf*Rinf_vec_tilde + induc*induc_vec_tilde;
// }