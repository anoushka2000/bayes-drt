functions {
	real HN_x(real omega, real tau0, real beta) {
		// Intermediate "x" variable
		return 1+ pow(omega*tau0,beta)*cos(beta*pi()/2);
	}
	real HN_y(real omega, real tau0, real beta){
		// Intermediate "y" variable
		return pow(omega*tau0,beta)*sin(beta*pi()/2);
	}
	real Zmod_HN(real alpha, real x, real y) {
		return pow(sqrt(square(x) + square(y)),-alpha);
	}
	real theta_HN(real alpha, real x, real y) {
		return -alpha*atan2(y,x);
	}
	real k_B() {return 8.617333e-5;} // Boltzmann constant (eV/K)
}
data {
	// dimensions
	int<lower=0> N; // number of measured frequencies
	int<lower=0> K; // number of HN basis functions
	int<lower=0> P; // number of distinct temperatures
	
	// impedance data
	vector[N] freq; // measured frequencies
	vector[2*N] Z; // stacked impedance vector ([Z' Z'']^T)
	vector<lower=0>[N] rel_Z_scale;
	
	// temperature
	vector[N] temp; // measurement temperatures (K)
	real<lower=0> T_base; // base temperature (K)
	int temp_start_indices[P-1]; // indices of new temperature starts (excluding 1st temperature)
	
	// fixed hyperparameters
	real<lower=0> sigma_min; // noise level floor
	real<lower=0> induc_scale; // inductance scale
	real<lower=0> max_delta_G;
	real<lower=0> ups_alpha;
	real<lower=0> ups_beta;
	real<lower=0> dG_alpha;
	real<lower=0> dG_beta;
	real<lower=0> ln_phi_scale; // scale of ln_phi_tau
	// scales for temperature std devs of HN shape parameters
	real<lower=0> sigmaT_alpha_scale;
	real<lower=0> sigmaT_beta_scale;
	
}
transformed data {
	vector [N] omega = freq*2*pi();
	vector[2*N] rel_Z_scale_stack = append_row(rel_Z_scale,rel_Z_scale);
	int temp_start_indices_expanded[P];
	temp_start_indices_expanded[1:P-1] = temp_start_indices;
	temp_start_indices_expanded[P] = N+1;
}
parameters {
	// impedance offsets
	real<lower=0> Rinf_base_raw;
	real<lower=0> induc_raw;
	
	// HN parameters
	vector<lower=0>[K] R_HN_base;
	vector<lower=0>[K] upsilon;
	ordered[K] lntau_HN_base;
	matrix<lower=0,upper=1>[P,K] alpha_HN;
	matrix<lower=0,upper=1>[P,K] beta_HN;
	
	// scale of HN shape parameter deviation with temperature
	vector<lower=0>[K] sigmaT_alpha_raw;
	vector<lower=0>[K] sigmaT_beta_raw;
	
	// activation parameters
	vector<lower=0,upper=max_delta_G>[K] delta_G; // activation energy for R_HN
	vector[K] ln_phi_tau_raw; // ln of activation energy factor for tau
	real<lower=0,upper=max_delta_G> delta_G_Rinf; // activation energy for Rinf
	
	// error structure parameters
	real<lower=0> sigma_res_raw;
	real<lower=0> alpha_prop_raw;
	real<lower=0> alpha_re_raw;
	real<lower=0> alpha_im_raw;
	
}
transformed parameters {
	real<lower=0> Rinf_base = Rinf_base_raw*100; // R_inf_base has effective scale of 100
	real<lower=0> induc = induc_raw*induc_scale; // induc has effective scale of induc_scale
	
	// scaled ln_phi
	vector[K] ln_phi_tau = ln_phi_tau_raw*ln_phi_scale; // ln_phi_tau has effective scale of 0.2
	
	// shape parameter deviation with temperature
	vector<lower=0>[K] sigmaT_alpha = sigmaT_alpha_raw*sigmaT_alpha_scale;
	vector<lower=0>[K] sigmaT_beta = sigmaT_beta_raw*sigmaT_beta_scale;
	matrix[(P-1),K] diffT_alpha;
	matrix[(P-1),K] diffT_beta;
	
	// error structure parameters
	real<lower=0> sigma_res = sigma_res_raw*0.05;
	real<lower=0> alpha_prop = alpha_prop_raw*0.05;
	real<lower=0> alpha_re = alpha_re_raw*0.05;
	real<lower=0> alpha_im = alpha_im_raw*0.05;
	vector[2*N] sigma_tot; 
	
	// parameters for Z_hat calculation
	vector[2*N] Z_hat;
	vector[N] Z_hat_re = rep_vector(0,N);
	vector[N] Z_hat_im = rep_vector(0,N);
	
	
	// calculate Z_hat
	for (k in 1:K){
		real phi_tau = exp(ln_phi_tau[k]);
		
		int p = 1; // temperature index
		 
		for (n in 1:N){
			real tau_HN = exp(lntau_HN_base[k] + (delta_G[k]*phi_tau/k_B())*(1/temp[n] - 1/T_base));
			real R_HN = R_HN_base[k]*exp((delta_G[k]/k_B())*(1/temp[n] - 1/T_base));
			real x = HN_x(omega[n],tau_HN,beta_HN[p,k]);
			real y = HN_y(omega[n],tau_HN,beta_HN[p,k]);
			real Zmod = Zmod_HN(alpha_HN[p,k],x,y);
			real theta = theta_HN(alpha_HN[p,k],x,y);
			
			Z_hat_re[n] += R_HN*Zmod*cos(theta);
			Z_hat_im[n] += R_HN*Zmod*sin(theta);
			
			// increment temperature index
			if (n+1 >= temp_start_indices_expanded[p])
				p += 1;
		}
	}
	
	Z_hat_re += Rinf_base*exp((delta_G_Rinf/k_B())*(1 ./temp - 1/T_base));
	Z_hat_im += induc*omega;
	Z_hat = append_row(Z_hat_re,Z_hat_im);
	
	// calculate shape parameter deviation with temperature
	for (p in 1:P-1) {
		diffT_alpha[p, ] = (alpha_HN[p+1, ] - alpha_HN[p, ]) ./ sigmaT_alpha';
		diffT_beta[p, ] = (beta_HN[p+1, ] - beta_HN[p, ]) ./ sigmaT_beta';
	}
	
	// calculate error scale
	sigma_tot = sqrt(square(sigma_min*rel_Z_scale_stack) + square(sigma_res*rel_Z_scale_stack) + square(alpha_prop*Z_hat)
									+ square(alpha_re*append_row(Z_hat_re,Z_hat_re)) 
									+ square(alpha_im*append_row(Z_hat_im,Z_hat_im))
									);
}
model {
	// HN peak magnitudes
	upsilon ~ gamma(ups_alpha,ups_beta);
	R_HN_base ~ exponential(upsilon);
	
	// impedance offsets
	Rinf_base_raw ~ std_normal();
	induc_raw ~ std_normal();
	
	// Arrhenius parameters
	delta_G_Rinf ~ inv_gamma(dG_alpha,dG_beta);
	delta_G ~ inv_gamma(dG_alpha,dG_beta);
	ln_phi_tau_raw ~ std_normal();
	
	// shape parameter deviations
	sigmaT_alpha_raw ~ std_normal();
	sigmaT_beta_raw ~ std_normal();
	for (p in 1:P-1) {
		diffT_alpha[p] ~ std_normal();
		diffT_beta[p] ~ std_normal();
	}
	
	// impedance
	Z ~ normal(Z_hat,sigma_tot);
	
	// error structure
	sigma_res_raw ~ std_normal();
	alpha_prop_raw ~ std_normal();
	alpha_re_raw ~ std_normal();
	alpha_im_raw ~ std_normal();
}