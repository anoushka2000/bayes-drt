functions {
	// for impedance calculation
	real HN_x(real omega, real tau0, real beta) {
		// Intermediate "x" variable
		return 1+ pow(omega*tau0,beta)*cos(beta*pi()/2);
	}
	real HN_y(real omega, real tau0, real beta){
		// Intermediate "y" variable
		return pow(omega*tau0,beta)*sin(beta*pi()/2);
	}
	real Zmod_HN(real alpha, real x, real y) {
		return pow(sqrt(square(x) + square(y)),-alpha);
	}
	real theta_HN(real alpha, real x, real y) {
		return -alpha*atan2(y,x);
	}
	// for matrix formatting
	vector upper_triangle_to_vec(matrix m, int K) {
		// Get upper triangle of matrix and flatten
		// matrix m should be [K,K]
		vector[K*(K-1)/2] x;
		int pos = 1;
		for (i in 1:K) {
			for (j in i+1:K) {
				x[pos] = m[i,j];
				pos += 1;
			}
		}
		return x;
	}
	
	// Arrhenius functions
	real k_B() {
		// Boltzmann constant (eV/K)
		return 8.617333e-5; 
	} 
	real arrhenius(real temp, real T_base, real dG, real y_base) {
		return y_base*exp((dG/k_B())*(1/temp - 1/T_base));
	}
}
data {
	// dimensions
	int<lower=0> J; // number of contacts
	int<lower=0> N; // number of measured frequencies
	int<lower=0> K; // number of HN basis functions
	int<lower=0> M; // number of pairwise comparisons to keep
	int<lower=0> P; // number of distinct temperatures
	
	// spatial coordinates
	vector[J] x_coord;
	vector[J] y_coord;
	
	// impedance data
	matrix[J,N] freq; //measured frequencies
	matrix[J,2*N] Z; // stacked impedance vector ([Z' Z'']^T)
	vector<lower=0>[N] rel_Z_scale;
	
	// temperature
	matrix[J,N] temp; // measurement temperatures (K)
	real<lower=0> T_base; // base temperature (K)
	int temp_start_indices[P]; // indices of new temperature starts
	real<lower=0> temp_uncertainty; // maximum temperature offset
	real<lower=0> temp_offset_scale; // scale for normal prior on temp_offset
	
	// for distance_vec truncation
	int compare_idx[M]; // indexes of distance_vec to keep for parameter comparison
	
	// fixed hyperparameters
	real<lower=0> sigma_min; // noise level floor
	real<lower=0> induc_scale; // inductance scale
	real<lower=0> max_delta_G; // upper bound on activation energy
	
	real<lower=0> R_base_scale_alpha;
	real<lower=0> R_base_scale_beta;
	
	// scales of spatial standard deviations
	real<lower=0> sigmaxy_lntau_scale;
	real<lower=0> sigmaxy_lnR_scale;
	real<lower=0> sigmaxy_alpha_scale;
	real<lower=0> sigmaxy_beta_scale;
	real<lower=0> sigmaxy_deltaG_scale;
	real<lower=0> sigmaxy_lnphiT_scale;
	
	real<lower=0> sigmaxy_tempoffset_scale;
	
	real<lower=0> ln_phi_T_scale;
	
}
transformed data {
	matrix [J,N] omega = freq*2*pi();
	matrix[J,J] dx_mat = rep_matrix(x_coord,J) - rep_matrix(x_coord,J)';
	matrix[J,J] dy_mat = rep_matrix(y_coord,J) - rep_matrix(y_coord,J)';
	matrix[J,J] D = sqrt(square(dx_mat) + square(dy_mat));
	vector[J*(J-1)/2] distance_vec_full = upper_triangle_to_vec(D,J);
	vector[M] distance_vec = distance_vec_full[compare_idx];
	vector[2*N] rel_Z_scale_stack = append_row(rel_Z_scale,rel_Z_scale);
	
	int temp_end_indices[P];
	for (p in 1:P-1) {
		temp_end_indices[p] = temp_start_indices[p+1] - 1;
	}
	temp_end_indices[P] = N;
}
parameters {
	// offsets
	vector<lower=0>[J] Rinf_base_raw;
	vector<lower=0>[J] induc_raw;
	
	// HN parameters
	matrix<lower=0>[J,K] R_HN_base;
	vector<lower=0>[K] R_base_scale;
	ordered[K] lntau_HN_base[J];
	matrix<lower=0,upper=1>[J,K] alpha_HN;
	matrix<lower=0,upper=1>[J,K] beta_HN;
	
	// Arrhenius parameters
	vector<lower=0,upper=max_delta_G>[J] delta_G_Rinf; // activation energy for Rinf
	matrix<lower=0,upper=max_delta_G>[J,K] delta_G; // activation energy for R_HN
	matrix[J,K] ln_phi_T_raw; // ln of activation energy factor for tau
	matrix<lower=-temp_uncertainty/temp_offset_scale,upper=temp_uncertainty/temp_offset_scale>[J,P] temp_offset_raw; 
	
	// parameter std deviations
	vector<lower=0>[K] sigmaxy_lntau_raw;
	vector<lower=0>[K] sigmaxy_lnR_raw;
	vector<lower=0>[K] sigmaxy_alpha_raw;
	vector<lower=0>[K] sigmaxy_beta_raw;
	vector<lower=0>[K] sigmaxy_deltaG_raw;
	vector<lower=0>[K] sigmaxy_lnphiT_raw;
	
	vector<lower=0>[P] sigmaxy_tempoffset_raw;
	
	// error structure parameters
	real<lower=0> sigma_res_raw;
	real<lower=0> alpha_prop_raw;
	real<lower=0> alpha_re_raw;
	real<lower=0> alpha_im_raw;
}
transformed parameters {
	// offsets
	vector<lower=0>[J] Rinf_base = Rinf_base_raw*100;
	vector<lower=0>[J] induc = induc_raw*induc_scale;
	
	// activation parameters
	matrix[J,K] ln_phi_T = ln_phi_T_raw*ln_phi_T_scale;
	matrix<lower=-temp_uncertainty,upper=temp_uncertainty>[J,P] temp_offset = temp_offset_raw*temp_offset_scale;
	matrix[J,N] temp_actual;
	
	// parameter std deviations
	vector<lower=0>[K] sigmaxy_lntau = sigmaxy_lntau_raw*sigmaxy_lntau_scale;
	vector<lower=0>[K] sigmaxy_lnR = sigmaxy_lnR_raw*sigmaxy_lnR_scale;
	vector<lower=0>[K] sigmaxy_alpha = sigmaxy_alpha_raw*sigmaxy_alpha_scale;
	vector<lower=0>[K] sigmaxy_beta = sigmaxy_beta_raw*sigmaxy_beta_scale;
	vector<lower=0>[K] sigmaxy_deltaG = sigmaxy_deltaG_raw*sigmaxy_deltaG_scale;
	vector<lower=0>[K] sigmaxy_lnphiT = sigmaxy_lnphiT_raw*sigmaxy_lnphiT_scale;
	
	vector<lower=0>[P] sigmaxy_tempoffset = sigmaxy_tempoffset_raw*sigmaxy_tempoffset_scale;
	
	// error structure parameters
	real<lower=0> sigma_res = sigma_res_raw*0.05;
	real<lower=0> alpha_prop = alpha_prop_raw*0.01;
	real<lower=0> alpha_re = alpha_re_raw*0.01;
	real<lower=0> alpha_im = alpha_im_raw*0.01;
	vector<lower=0>[2*N] sigma_tot[J]; 
	
	// parameter difference arrays
	vector[M] diff_lntau[K];
	vector[M] diff_lnR[K];
	vector[M] diff_alpha[K];
	vector[M] diff_beta[K];
	vector[M] diff_deltaG[K];
	vector[M] diff_lnphiT[K];
	
	vector[M] diff_tempoffset[P];
	
	// parameters to store impedance calculation
	vector[2*N] Z_hat[J];
	vector[N] Z_hat_re[J];
	vector[N] Z_hat_im[J];
	
	// calculate actual temp
	for (p in 1:P) {
		temp_actual[ ,temp_start_indices[p]:temp_end_indices[p]] = temp[ ,temp_start_indices[p]:temp_end_indices[p]]
																   + rep_matrix(temp_offset[ ,p],temp_end_indices[p] +1 - temp_start_indices[p]);
	}
	
	// calculate Z_hat
	for (j in 1:J){
		Z_hat_re[j] = rep_vector(0,N);
		Z_hat_im[j] = rep_vector(0,N);
		for (k in 1:K){
			real phi_T = exp(ln_phi_T[j,k]);
			
			for (n in 1:N){
				// calculate R and tau at temp
				real tau_HN = arrhenius(temp_actual[j,n], T_base, phi_T*delta_G[j,k], exp(lntau_HN_base[j,k]));
				real R_HN = arrhenius(temp_actual[j,n], T_base, delta_G[j,k], R_HN_base[j,k]);
				
				// temp-dependent R and tau feed into Z_hat calcs
				real x = HN_x(omega[j,n],tau_HN,beta_HN[j,k]);
				real y = HN_y(omega[j,n],tau_HN,beta_HN[j,k]);
				real Zmod = Zmod_HN(alpha_HN[j,k],x,y);
				real theta = theta_HN(alpha_HN[j,k],x,y);
				Z_hat_re[j,n] += R_HN*Zmod*cos(theta);
				Z_hat_im[j,n] += R_HN*Zmod*sin(theta);
			}
		}
		
		Z_hat_re[j] += (Rinf_base[j]*exp((delta_G_Rinf[j]/k_B())*(1 ./temp_actual[j] - 1/T_base)))';
		Z_hat_im[j] += induc[j]*omega[j]';
		Z_hat[j] = append_row(Z_hat_re[j],Z_hat_im[j]);
	}
	
	// calculate parameter differences
	for (k in 1:K) {
		vector[J] lntau_k = to_vector(lntau_HN_base[ ,k]);
		vector[J] lnR_k = log(R_HN_base[ ,k]);
		vector[J] alpha_k = alpha_HN[ ,k];
		vector[J] beta_k = beta_HN[ ,k];
		vector[J] deltaG_k = delta_G[ ,k];
		vector[J] lnphiT_k = ln_phi_T[ ,k];
		
		matrix[J,J] dlntau_k = rep_matrix(lntau_k,J) - rep_matrix(lntau_k,J)';
		matrix[J,J] dlnR_k = rep_matrix(lnR_k,J) - rep_matrix(lnR_k,J)';
		matrix[J,J] dalpha_k = rep_matrix(alpha_k,J) - rep_matrix(alpha_k,J)';
		matrix[J,J] dbeta_k = rep_matrix(beta_k,J) - rep_matrix(beta_k,J)';
		matrix[J,J] ddeltaG_k = rep_matrix(deltaG_k,J) - rep_matrix(deltaG_k,J)';
		matrix[J,J] dlnphiT_k = rep_matrix(lnphiT_k,J) - rep_matrix(lnphiT_k,J)';
		
		vector[J*(J-1)/2] diff_lntau_full = upper_triangle_to_vec(dlntau_k,J);
		vector[J*(J-1)/2] diff_lnR_full = upper_triangle_to_vec(dlnR_k,J);
		vector[J*(J-1)/2] diff_alpha_full = upper_triangle_to_vec(dalpha_k,J);
		vector[J*(J-1)/2] diff_beta_full = upper_triangle_to_vec(dbeta_k,J);
		vector[J*(J-1)/2] diff_deltaG_full = upper_triangle_to_vec(ddeltaG_k,J);
		vector[J*(J-1)/2] diff_lnphiT_full = upper_triangle_to_vec(dlnphiT_k,J);
		
		diff_lntau[k] = diff_lntau_full[compare_idx] ./ (distance_vec*sigmaxy_lntau[k]);
		diff_lnR[k] = diff_lnR_full[compare_idx] ./ (distance_vec*sigmaxy_lnR[k]);
		diff_alpha[k] = diff_alpha_full[compare_idx] ./ (distance_vec*sigmaxy_alpha[k]);
		diff_beta[k] = diff_beta_full[compare_idx] ./ (distance_vec*sigmaxy_beta[k]);
		diff_deltaG[k] = diff_deltaG_full[compare_idx] ./ (distance_vec*sigmaxy_deltaG[k]);
		diff_lnphiT[k] = diff_lnphiT_full[compare_idx] ./ (distance_vec*sigmaxy_lnphiT[k]);
	}
	
	for (p in 1:P) {
		vector[J] tempoffset_p = temp_offset[ ,p];
		matrix[J,J] dtempoffset_p = rep_matrix(tempoffset_p,J) - rep_matrix(tempoffset_p,J)';
		vector[J*(J-1)/2] diff_tempoffset_full = upper_triangle_to_vec(dtempoffset_p,J);
		diff_tempoffset[p] = diff_tempoffset_full[compare_idx] ./ (distance_vec*sigmaxy_tempoffset[p]);
		
	}
	
	// calculate error scale
	for (j in 1:J) {
		sigma_tot[j] = sqrt(square(sigma_min*rel_Z_scale_stack) + square(sigma_res*rel_Z_scale_stack) + square(alpha_prop*Z_hat[j])
									+ square(alpha_re*append_row(Z_hat_re[j],Z_hat_re[j])) 
									+ square(alpha_im*append_row(Z_hat_im[j],Z_hat_im[j]))
									);
	}
}
model {
	// offsets
	Rinf_base_raw ~ std_normal();
	induc_raw ~ std_normal();
	
	// HN parameters
	R_base_scale ~ inv_gamma(R_base_scale_alpha,R_base_scale_beta);
	for (j in 1:J) {
		R_HN_base[j] ~ normal(0,R_base_scale);
	}
	
	// Arrhenius parameters
	for (j in 1:J) {
		ln_phi_T_raw[j] ~ std_normal();
	}
	for (j in 1:J) {
		temp_offset_raw[j] ~ std_normal();
	}
	
	// parameter differences
	for (k in 1:K) {
		diff_lntau[k] ~ std_normal();
		diff_lnR[k] ~ std_normal();
		diff_alpha[k] ~ std_normal();
		diff_beta[k] ~ std_normal();
		diff_deltaG[k] ~ std_normal();
		diff_lnphiT[k] ~ std_normal();
	}
	
	for (p in 1:P) {
		diff_tempoffset[p] ~ std_normal();
	}
	
	// parameter std deviations
	sigmaxy_lntau_raw ~ std_normal();
	sigmaxy_lnR_raw ~ std_normal();
	sigmaxy_alpha_raw ~ std_normal();
	sigmaxy_beta_raw ~ std_normal();
	sigmaxy_deltaG_raw ~ std_normal();
	sigmaxy_lnphiT_raw ~ std_normal();
	
	// impedance
	for (j in 1:J) {
		Z[j] ~ normal(Z_hat[j],sigma_tot[j]);
	}
	
	// error structure
	sigma_res_raw ~ std_normal();
	alpha_prop_raw ~ std_normal();
	alpha_re_raw ~ std_normal();
	alpha_im_raw ~ std_normal();
}